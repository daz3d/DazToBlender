// DAZ Studio version 4.12.0.86 filetype DAZ Script

(function(){
	var s_sBridge = "Blender"
	var s_sDazBridgeName = String( "Daz To %1" ).arg( s_sBridge )
	var s_oFileInfo = new DzFileInfo( getScriptFileName() );
	var s_sScriptPath = s_oFileInfo.path();
	// To be able to use the IDE Input your absolute Path.
	// s_sScriptPath = "D:/GitRepos/DazToBlender/Daz Studio/appdir_common/scripts/support/DAZ"	
	var s_sToolName = s_sDazBridgeName;
	var s_sMorphDialog = String( "Dz%1MorphSelectionDialog" ).arg( s_sBridge )
	s_oFileInfo.deleteLater();

	var s_aFigures = [];
	var s_aEnvProp = [];
	
	var s_sFig = "FIG";
	var s_sEnv = "ENV";

	var s_aToReparent = [];
	
	var s_oMeshTypes = {
		"Figure" :3,
		"Mesh" : 1,
		"Other" : 0,
		"Bone" : -1,
		"NoFacets" : -2,
		"Empty" : -3
	};
	
	var s_oExportTypes = {
		"Both" : 2,
		"Figure" : 1,
		"EnvProp" : 0,
		"None" : -1
	};
	var s_nExportType = s_oExportTypes.None;
	var s_aExportableProperties = [];


	var s_sRootPath = "";
	var s_sCustomPath = "";
	var s_sPresetPath = "";
	var s_sConfigPath = "";
	
	var s_sFbxPath = "";
	var s_sMorphRules = "";
	var s_oMorphLinks = {};
	var s_aMorphNamesToExport = [];
	var s_oSkeletonData = {};
	var s_oSkeletonTransforms = {}
	var s_oLimitsData = {};
	var s_oHeadTailData = {};
	var s_oJointOrientation = {};
	var s_oPoseData = {};

	var s_nLenName = 0;
	var s_nMaxName = 19;
	var s_sAlf = "1234567890abcdefghijklmnopqrstuvwxyz";
	
	var s_vecDef = new DzVec3( 0, 0, 0 );
	var s_quatDef = new DzQuat( 0, 0, 0, 1, true );
	var s_mtxDef = new DzMatrix3( s_quatDef );
	
	var s_aPoseData = [];
	var s_oOrgName = {};

	// Setting variables
	var s_nSubDivLevel;
	var s_bIncludeAnim;
	var s_bRemoveIncompatible;
	var s_bIncludeMorphs;
	var s_bCollectTextures;
	
	
	
// --- START Sub Script ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/remote_operation/sub_script/start
 	
 	// - Extracted functions
	// - Returns Scripts Paramater
 	// - Adjusted to be used within bridge
	/*********************************************************************/
	// Object? 
	function executeSubScript( sScript, aArgs ){
 
		/*********************************************************************/
		// String : A function for retrieving a translation if one exists
		function text( sText )
		{
			// If the version of the application supports qsTr()
			if( typeof( qsTr ) != "undefined" ){
				// Return the translated (if any) text
				return qsTr( sText );
			}
	 
			// Return the original text
			return sText;
		};
	 
		/*********************************************************************/
		// Declare working variables
		var sTitle, sMessage;
	 
		// Define common strings
		var sButton = text( "&OK" );
	 
		// Define the base path of the script we'll call; without the file extension
		var sBasePath = String( "%1/%2" ).arg( s_sScriptPath ).arg( sScript );
		
		// Create a script object
		var oScript = new DzScript();
	 
		// Attempt to find our script; doing it this way, we can debug with an
		// ascii file and distribute a binary [encrypted] file with the same name...
		// without having to update the contents of the script or manually handle
		// the file extensions; requires 3.0.1.5 or newer
		var sScriptPath = oScript.getScriptFile( sBasePath );
	 
		// If a script is found
		if( !sScriptPath.isEmpty() ){
			// If the script loads
			if( oScript.loadFromFile( sScriptPath ) ){
				// Execute the script; pass in an array of arguments;
				// passing in arguments requires 2.2.2.17 or newer
				oScript.execute( aArgs );
				return oScript.result();
			// If the script doesn't load
			} else {
				// Define text variables for the message
				sTitle = text( "Read Error" );
				sMessage = text( "The '%1' file could not be loaded." ).arg( sScriptPath );
				// Inform the user
				MessageBox.information( sMessage, sTitle, sButton );
			}
		// If a script is not found
		} else {
			// Define text variables for the message
			sTitle = text( "File Not Found" );
			sMessage = text( "A '%1.ds(a|b|e)' file could not be found." ).arg( sBasePath );
			// Inform the user
			MessageBox.information( sMessage, sTitle, sButton );
		}
	};

// --- END Sub Script ----
	
// --- START node_properties ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/properties/node_properties/start
 	
 	// - Extraccted functions

	/*********************************************************************/
	// Array<DzProperty> : A function for getting a list of the properties in a group
	function getGroupProperties( oGroup, bTraverse, bRecurse )
	{
		// Declare an array to hold properties
		var aProperties = [];
		
		// If a group is not passed in
		if( !oGroup ){
			// We are done, return an empty array
			return aProperties;
		}
		
		// Get the number of proeprties in the group
		var nProperties = oGroup.getNumProperties();
		// Pre-size the properties array
		aProperties = new Array( nProperties );
		// Iterate over the properties, setting each element in the array
		for( var i = 0; i < nProperties; i += 1 ){
			// Assign the property to the position in the array
			aProperties[ i ] = oGroup.getProperty( i );
		}
		
		// If we are recursing
		if( bRecurse ){
			// Concatenate the properties array from child groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getFirstChild(), true, bRecurse ) );
		}
		
		// If we are traversing
		if( bTraverse ){
			// Concatenate the properties array from sibling groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getNextSibling(), bTraverse, bRecurse ) );
		}
 		
		// Return the array of properties
		return aProperties;
	};
	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting the list properties for an element
	function getElementProperties( oElement, bTraverse, bRecurse )
	{
		// Get the property group tree for the element
		var oPropertyGroupTree = oElement.getPropertyGroups();
		
		// If the application version is 4.9.4.101 or newer and we want all properties
		if( App.version64 >= 0x0004000900040065 && bTraverse && bRecurse ){
			// Return the properties for the element
			return oPropertyGroupTree.getAllProperties();
		}
		
		// Get the first group in the tree
		var oPropertyGroup = oPropertyGroupTree.getFirstChild();
		// Return the properties for the element
		return getGroupProperties( oPropertyGroup, bTraverse, bRecurse );
	};

// --- END node_properties ----
	
	
// --- START export_fbx_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_fbx_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportFBX( oNode, sName, nIdx, bAscii )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Autodesk Filmbox (*.fbx) exporter
		var sClassName = "DzFbxExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Selected
			oSettings.setBoolValue( "doSelected", false );
			// No Hidden
			oSettings.setBoolValue( "doVisible", true );
			// Figures
			oSettings.setBoolValue( "doFigures", true );
			
			var bIsEnv = sName.startsWith( s_sEnv );
			// Props
			oSettings.setBoolValue( "doProps", bIsEnv );
			// Lights
			oSettings.setBoolValue( "doLights", bIsEnv );
			// Cameras
			oSettings.setBoolValue( "doCameras", bIsEnv );
			
			// Animations
			oSettings.setBoolValue( "doAnims", s_bIncludeAnim );
			// Morphs
			oSettings.setBoolValue( "doMorphs", true );
			
			// Fps
			oSettings.setBoolValue( "doFps", true );
			
			// Morph Rules
			// Format for rules is "Match1\nAction1\nMatch2\nAction2\nMatch3\nAction3",
			// where Match# is a string to search for and Action# is one of Bake|Export|Ignore
			// The names of the morphs are in the form: node_name.parameter_name
			// The default action is to Bake
			// So "FBMHeavy\nExport\nThin\nExport" would export all morphs that have FBMHeavy and all morphs that have Thin in the name
			oSettings.setStringValue( "rules", s_sMorphRules );
			
			// Format
			// Format for format is "Year# -- Type",
			// where Year# is one of 2006|2009|2010|2011|2012|2013|2014 and
			// Type is one of Ascii|Binary
			if( bAscii ){
				oSettings.setStringValue( "format", "FBX 2014 -- Ascii" );
			} else {
				oSettings.setStringValue( "format", "FBX 2014 -- Binary" );
			}
			
			// Embed Textures
			oSettings.setBoolValue( "doEmbed", false );
			// Collect Textures To Folder
			oSettings.setBoolValue( "doCopyTextures", false );
			// Merge Diffuse and Opacity Textures
			oSettings.setBoolValue( "doDiffuseOpacity", false );
			// Merge Clothing Into Figure Skeleton
			oSettings.setBoolValue( "doMergeClothing", true );
			// Convert Clothing to Static Geometry
			oSettings.setBoolValue( "doStaticClothing", false );
			// Allow Degraded Skinning
			oSettings.setBoolValue( "degradedSkinning", false );
			// Allow Degraded Scaling
			oSettings.setBoolValue( "degradedScaling", false );
			// SubD Information
			oSettings.setBoolValue( "doSubD", false );
			// Collapse UV Tiles
			//oSettings.setBoolValue( "doCollapseUVTiles", false );
			
			oSettings.setBoolValue( "doLocks", false );
			oSettings.setBoolValue( "doLimits", false );
			oSettings.setBoolValue( "doBaseFigurePoseOnly", false );
			oSettings.setBoolValue( "doHelperScriptScripts", false );
			oSettings.setBoolValue( "doMentalRayMaterials", false );
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Define whether or not to show the options after prompting for a file;
				// prior to 4.9.3.22 this exporter ignored this option entirely,
				// running silent was implied by virtue of being run via script
				oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			}
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/"
			s_sFbxPath = sName + "/" + sName + nIdx + "/";
			if( bAscii ){
				sPath += "A_" + sName + ".fbx"
				s_sFbxPath += "A_" + sName + ".fbx"
			} else {
				sPath += "B_" + sName + ".fbx"
				s_sFbxPath += "B_" + sName + ".fbx"
			}
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			// Clean up; don't leak memory
			oExporter.deleteLater();
			
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_fbx_silent ----
	
	
// --- START export_obj_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_obj_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportOBJ( oNode, sName, nIdx )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Wavefront Object (*.obj) exporter
		var sClassName = "DzObjExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Set the scale to write the data
			oSettings.setFloatValue( "Scale", 100.0 );
			// Set the lateral axis to X
			oSettings.setStringValue( "LatAxis", "X" );
			// Set the vertical axis to Y
			oSettings.setStringValue( "VertAxis", "Y" );
			// Set the depth axis to Z
			oSettings.setStringValue( "DepthAxis", "Z" );
			// Do not invert the lateral axis
			oSettings.setBoolValue( "InvertLat", false );
			// Do not invert the vertical axis
			oSettings.setBoolValue( "InvertVert", false );
			// Do not invert the depth axis
			oSettings.setBoolValue( "InvertDepth", false );
			// Do not ignore the geometry of invisible nodes
			oSettings.setBoolValue( "IgnoreInvisible", true );
			// Do not weld seams between parent and child bones on legacy figures - deprecated
			oSettings.setBoolValue( "WeldSeams", false );
			// Do not remove vertices that are floating, connected to nothing - i.e. LOD
			oSettings.setBoolValue( "RemoveUnusedVerts", true );
			// Write vertex textures - UVs
			oSettings.setBoolValue( "WriteVT", true );
			// Do not write vertex normals
			oSettings.setBoolValue( "WriteVN", false );
			// Do not write object statements for each root node - i.e. figures, props
			oSettings.setBoolValue( "WriteO", false );
			
			// Write facet groups
			oSettings.setBoolValue( "WriteG", false );
			// Write facet groups according to whatever the geometry already has
			oSettings.setBoolValue( "GroupGeom", false );
			// Do not write facet groups according to the node it is associated with
			oSettings.setBoolValue( "GroupNodes", false );
			// Do not write facet groups according to surface groups
			oSettings.setBoolValue( "GroupSurfaces", false );
			// Do not write one facet group
			oSettings.setBoolValue( "GroupSingle", false );
			
			// Write surface groups
			oSettings.setBoolValue( "WriteUsemtl", true );
			
			// Do not write a material library
			oSettings.setBoolValue( "WriteMtllib", true );
			
			oSettings.setBoolValue( "OriginalMaps", true );
			// Do not collect texture maps
			oSettings.setBoolValue( "CollectMaps", false );
			// Do not convert texture maps
			oSettings.setBoolValue( "ConvertMaps", false );
			
			// If the version is 4.5.0.114 or newer
			if( App.version64 >= 0x0004000500000072 ){
				// Do not limit export to selection
				oSettings.setBoolValue( "SelectedOnly", false );
				// Do not limit export to the selected roots
				oSettings.setBoolValue( "SelectedRootsOnly", false );
				// Do not limit export to the primary selected root;
				// this setting overrides SelectedRootsOnly
				oSettings.setBoolValue( "PrimaryRootOnly", false );
				// Do not export items that are parented to the selection
				oSettings.setBoolValue( "IncludeParented", false );
				// Do not triangulate n-gons
				oSettings.setBoolValue( "TriangulateNgons", false );
			}
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Do not collapse UVs Tiles
				oSettings.setBoolValue( "CollapseUVTiles", false );
				
				// Show individual settings in the dialog
				oSettings.setBoolValue( "ShowIndividualSettings", false );
			}
			
			// If the version is 4.10.0.73 or newer
			if( App.version64 >= 0x0004000a00000049 ){
				// Set floating point precision; default is 8
				oSettings.setIntValue( "FloatPrecision", 6 );
			}
			
			// Define whether or not to show the options after prompting for a file
			oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/" + sName+ ".obj";
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_obj_silent ----
	
	/*********************************************************************/
	
	// void : ...
	function addBanner( wDlg, sImagePath )
	{
		var imgImage = new Image( sImagePath );
		var pixImage = (new Pixmap()).fromImage( imgImage );
		
		var wLabel = new DzLabel( wDlg );
		wLabel.pixmap = pixImage;
		wDlg.addWidget( wLabel );
	};
	
	/*********************************************************************/
	// Array<Number> : ...
	// TODO : refactor - efficiency
	function getBoneTransformValues( oNode )
	{
		var aPosRotScale = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
		
		var aAxis = [ "X", "Y", "Z" ];
		var regxWhitespace = /\s+/g;
		
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		var sLabel;
		var sName;
		
		var aProperties = getElementProperties( oNode, true, true );
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProperty = aProperties[i];
			oOwner = oProperty.getOwner();
			if( !oOwner.inherits( "DzBone" ) ){
				continue;
			}
			
			for( var j = 0; j < aAxis.length; j += 1 ){
				sAxis = aAxis[j];
				aNames = [ sAxis + "Translate", sAxis + "Rotate" ];//Skip sAxis + "Scale"
				for( var k = 0; k < aNames.length; k += 1 ){
					sName = aNames[k];
					if( oProperty.name == sName ){
						if( !oProperty.isHidden() ){
							sLabel = oProperty.getLabel().toLowerCase().replace( regxWhitespace, "" );
							sName = sName.toLowerCase().replace( regxWhitespace, "" );
							if( !sName.startsWith( sLabel ) ){
								aPosRotScale[k*3+j] = 1;
							}
						}
					}
				}
			}
		}
		
		return aPosRotScale;
	};
	
	/*********************************************************************/
	// void : ...
	function writeMemo( sFilename, sMemo )
	{
		writeDataFile( [ sMemo ], sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function applyDefaultTransforms( oBaseNode )
	{
		var oNode;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( getObjectType( oNode ) == "BONE" ){
				oNode.setLocalPos( s_vecDef );
				oNode.setLocalRot( s_quatDef );
				oNode.setLocalScale( s_mtxDef );
			}
		}
		
		oBaseNode.setLocalPos( s_vecDef );
		oBaseNode.setLocalRot( s_quatDef );
		oBaseNode.setLocalScale( s_mtxDef );
	};

	/*********************************************************************/
	// Destructive Changes the names of the Assets in Daz
	// void : ...
	function updateName( oBaseNode, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( bIsFigure && oTopNode.name != "hip" ){
				continue;
			}
			
			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes < 1 ){
			return;
		}
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sLabel =oNode.getLabel();
			sName = oNode.name;
			if( sLabel in s_oOrgName ){
				oNode.setName(s_oOrgName[sLabel])
			}
			else{
				s_oOrgName[sLabel] = sName
				oNode.setName( sLabel )
			}
			
		};
	};

	/*********************************************************************/
	// void : ...
	function loadPoseData( oBaseNode, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			
			if( bIsFigure && !oTopNode.inherits( "DzBone" ) ){
				continue;
			}

			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;

		if( nNodes < 1 ){
			return;
		}
		
		var oNode;
		var sObjectType;
		var vecPos;
		var quatRot;
		var mtxScale;
		s_oPoseData = {};
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sObjectType = getObjectType( oNode );
			vecPos = oNode.getLocalPos();
			quatRot = oNode.getLocalRot();
			mtxScale = oNode.getLocalScale();
			oParent = oNode.getNodeParent();
			s_aPoseData.push( [ oNode.name, sObjectType, vecPos, quatRot, mtxScale ] );
			sLabel = oNode.getLabel();	
			sName = oNode.name;		
			oName = s_oPoseData[sName] = {};
			oName["Name"] = sName;
			oName["Label"] = sLabel;
			oName["Object Type"] = sObjectType;
			if(sObjectType == "MESH"){
				oName["Object"] = oNode.getObject().name; 
			}
			else{
				oName["Object"] = "EMPTY"
			};
			oName["Position"] = [
				vecPos.x,
				vecPos.y,
				vecPos.z
			];
			oName["Rotation"] = [
				oNode.getXRotControl().getLocalValue(),
				oNode.getYRotControl().getLocalValue(),
				oNode.getZRotControl().getLocalValue(),
				];
			oName["Scale"] = [
				mtxScale.m11,
				mtxScale.m22,
				mtxScale.m33
			];	
		}
	
		
	};
	
	/*********************************************************************/
	// void : ...
	function restorePose( oBaseNode )
	{
		var oTopNode;
		var aNodes;
		var oNode;
		var aPose;
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( oTopNode.name != "hip" ){
				continue;
			}
			
			aNodes = oTopNode.getNodeChildren( true );
			aNodes.push( oTopNode );
			aNodes.unshift( oBaseNode );
			for( var j = 0; j < aNodes.length; j += 1 ){
				oNode = aNodes[j];
				if( getMeshType( oNode ) != s_oMeshTypes.Bone && j > 0 ){
					continue;
				}
				
				for( var k = 0; k < s_aPoseData.length; k += 1 ){
					aPose = s_aPoseData[k];
					if( aPose[0] == oNode.name ){
						oNode.setLocalPos( aPose[2] );
						oNode.setLocalRot( aPose[3] );
						oNode.setLocalScale( aPose[4] );
						break;
					}
				}
			}
		}
	};

	/*********************************************************************/
	// void : ...
	function changeLock ( oProperty, bLock ) {
		if ( ! oProperty ) {
			return;
		}
		oProperty.lock( bLock );
	}

	/*********************************************************************/
	// void : ...
	function setLock( oBaseNode, bLock, bIsFigure )
	{
		var aNodes = oBaseNode.getNodeChildren( true );
		if( !bIsFigure ){
			aNodes.push( oBaseNode );
		}
				
		var oNode;
		var oTransform;

		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getObjectType( oNode ) == 'BONE' ){
				continue;
			}
			// Translations
			oTransform = oNode.getXPosControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getYPosControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getZPosControl();
			changeLock( oTransform, bLock );
			
			// Rotations
			oTransform = oNode.getXRotControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getYRotControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getZRotControl();
			changeLock( oTransform, bLock );
			
			// Scale
			oTransform = oNode.getScaleControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getXScaleControl();
			changeLock( oTransform, bLock );
			curTransform = oNode.getYScaleControl();
			changeLock( oTransform, bLock );
			curTransform = oNode.getZScaleControl();
			changeLock( oTransform, bLock );
		}
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : rename
	function getObjectType( oNode )
	{
		if( oNode.inherits( "DzBone" ) ){
			return "BONE";
		}
		
		if( oNode.inherits( "DzLight" ) ){
			return "LIGHT";
		}
		
		if( oNode.inherits( "DzCamera" ) ){
			return "CAMERA";
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return "EMPTY";
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return "EMPTY";
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return "EMPTY";
		}
		
		return "MESH";
	};
	
	/*********************************************************************/
	// void : ...
	// Morph names that are too long will cause an error in Blender 2.79.
	// Note: destructive - modifies the scene contents
	function truncateSkeletonNames( oBaseNode )
	{
		var oNode;
		var sName;
		var sTmp;
		
		var nCount = 0;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			sName = oNode.name;
			if( sName.length >= s_nMaxName ){
				sTmp = sName.substring( 0, s_nMaxName-2 );
				nCount = nCount % 36;
				sTmp = sTmp + "_" + s_sAlf.substr( nCount, 1 );
				oNode.name = sTmp;
				s_nLenName = s_nMaxName;
				nCount = nCount + 1;
			} else {
				if( sName.length > s_nLenName ){
					s_nLenName = sName.length;
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// Delete previous export
	// TODO : Create a Config folder to Hold the User's Daz Directories
	function prepareForExport( nType )
	{
		var oDir = new DzDir( "" );
		var sPath = oDir.homePath() + "/";
		
		s_sRootPath = sPath;
		
		var aFiles;
		var sDelPath;
		var oDelDir = new DzDir( "" );
		
		var aRoot = ["Documents","DAZ 3D", "Bridges", s_sDazBridgeName] 
		var aFolders = ["Exports", "Config", "Presets"];
		var aSubs = [s_sEnv, s_sFig]

		for( var i = 0; i < aRoot.length; i += 1 ){
			// Create Base Directory
			
			sPath = s_sRootPath + aRoot[i] + "/";
			s_sRootPath = sPath;

			if ( i == 4 ){
				s_sPresetPath = sPath;
			}
			if ( i == 5 ){
				s_sConfigPath = sPath;
			}
			// Create Directories
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			};
		};
		for( var i = 0; i < aFolders.length; i += 1 ){
			// Create Folders 
			var sTempPath = sPath + aFolders[i] + "/";
			if( i == 0 ){
				s_sRootPath = sTempPath;
				
			}
			if( i == 1 ){
				s_sConfigPath = sTempPath;
			}
			if( i == 2 ){
				s_sPresetPath = sTempPath;
			}
			// Create Directories
			oDir.setPath( sTempPath );
			if( !oDir.exists() ){
				if( i == 0 ){
					MessageBox.information( qsTr( "You can manually locate your export files here:\n%1" ).arg( sTempPath ), 
											qsTr( "Your Export Path" ), 
											qsTr( "&Continue" ) );
				}
				oDir.mkdir( sTempPath );
			}
		}

		// Create Type Directories
		if(nType == s_oExportTypes.EnvProp ){
			sPath = s_sRootPath + aSubs[0] + "/"
			sType = aSubs[0]	
			};
		if(nType == s_oExportTypes.Figure ){
			sPath = s_sRootPath + aSubs[1] + "/"
			sType = aSubs[1]	
			};	

		// Create Directories
		oDir.setPath( sPath );
		if( !oDir.exists() ){
			oDir.mkdir( sPath );
		};
		
		// Find Users Daz Content Paths
		var aContentDir = findUsersContent( s_sConfigPath );
		writeConfigPath( aContentDir );

		// Replace RootPath if Custom Path is Enabled
		if( useCustomPath() ){
			sPath = sPath.replace( s_sRootPath, s_sCustomPath );
			oDir.setPath( sPath );
			s_sRootPath = s_sCustomPath;
		};

		var aDirs = []
		// Delete Files
		aFiles = oDir.getFilesFromDir( [], true );
		for( var j = 0; j < aFiles.length; j += 1 ){
			var oFile = new DzFile( aFiles[j] );
			var sFileName = oFile.fileName()
			dir = oDir.relativeFilePath( aFiles[j] ).replace(  sFileName, "" )
			aDirs.pushIfNotExists( dir );
			oDir.remove( aFiles[j] );

		};
	
		// Delete Dirs
		for ( var j = 0; j < aDirs.length; j += 1 ){
			sDelPath = sPath + aDirs[j]
			oDelDir.setPath( sDelPath );
			if( oDelDir.exists() ){
				sDirName = oDelDir.dirName()
				oDelDir.rmdir( sDelPath );
				if( oDelDir.cdUp() && sDirName != sType ){
					oDelDir.rmdir()
				}
			}	
		};

		
	};
	/*********************************************************************/
	// Array : Find the Daz Paths where content is installed
	function findUsersContent()
	{
		var oContentMgr = App.getContentMgr();
		var nContentDirCount = oContentMgr.getNumContentDirectories();
		var aContentDir = [];
		for(var i=0; i < nContentDirCount; i++){
			var sContentDirPath = oContentMgr.getContentDirectoryPath( i );
			aContentDir.push( sContentDirPath )
		}
		return aContentDir
		
	}
	/*********************************************************************/
	// void : ...
	function writeConfigPath( aContentDir )
	{
		var sDazPath = s_sConfigPath + "daz_paths.json";
		var oCurFile = new DzFile( sDazPath );
		var oDazFile = new DzFile( sDazPath );
		var oDazJson = {};
		oCurFile.open( DzFile.ReadOnly );
		var sDazFile = oCurFile.read();
		if ( sDazFile != "" ){
			oDazJson = JSON.parse( sDazFile )
		}
		oCurFile.close()
		oDazFile.open( DzFile.WriteOnly );

		if( oDazJson["Custom Path"] ){
			s_sCustomPath = oDazJson["Custom Path"];
		}

		oDazJson["Content Directories"] = aContentDir;
		oDazJson["Default Path"] = s_sRootPath;
		oDazJson["Custom Path"] = s_sCustomPath;
		
		oDazFile.write( JSON.stringify( oDazJson, null, 4 ) );
		oDazFile.close();

	};

	/*********************************************************************/
	// Boolean : Check if Custompath Should be Used.
	function useCustomPath()
	{
		var sDazPath = s_sConfigPath + "daz_paths.json";
		var oDazFile = new DzFile( sDazPath );
		var oDazJson = {};
		oDazFile.open( DzFile.ReadOnly );
		var sDazFile = oDazFile.read()
		if ( sDazFile ){
			oDazJson = JSON.parse( sDazFile )
		}
		oDazFile.close();
		return oDazJson["Use Custom Path"]
	};

	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function makeEndDir( nIdx, sName )
	{
		var oDir = new DzDir( "" );
		
		var sPath = s_sRootPath;
		
		var aSubs = [ sName, sName + nIdx ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath += aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
		}
	};
	/*********************************************************************/
	// Bool : ...
	// Export Settings Dialog
	function promptSettings( oNode )
	{
		// Get the current style
        var oStyle = App.getStyle();
        // Get the general margin
        var nMargin = oStyle.pixelMetric( "DZ_GeneralMargin" )
		
		var wSettingsDialog = new DzBasicDialog();
		wSettingsDialog.caption = s_sToolName + ": Settings";
		if( oNode ){
			wSettingsDialog.caption += " - " + oNode.getLabel();
		}
		
		var sKey = wSettingsDialog.caption.replace( / /g, "" ) + "Dlg";
		wSettingsDialog.getWidget().objectName = sKey;
		

		// SubDivision level radio button group
		var wSubDivGroup = new DzVButtonGroup( wSettingsDialog );
		wSubDivGroup.columns = 1;
		var wSubDivLbl = new DzLabel( wSubDivGroup );
		wSubDivLbl.text = "SubDivision Level"
		var wRadioBtn;
		for( var i = 0; i < 3; i += 1 ){
			wRadioBtn = new DzRadioButton( wSubDivGroup );
			wRadioBtn.text = "Level " + i;
		}
		wSubDivGroup.selected = 0;
		wSettingsDialog.addWidget( wSubDivGroup );
		
		// Create Morph Layout
		var lytMorphs = new DzHButtonGroup( wSettingsDialog );
        lytMorphs.margin = nMargin;
        lytMorphs.spacing = nMargin;
		wSettingsDialog.addWidget( lytMorphs );

		// Checkbox to include morph data
		var wIncludeMorphsCbx = new DzCheckBox( lytMorphs );
		wIncludeMorphsCbx.text = "Include Morphs";
		wIncludeMorphsCbx.checked = false;

		// Button to choose morph data
		var wChooseMorphsBut = new DzPushButton( lytMorphs );
		wChooseMorphsBut.text = "Choose Morphs";
		
		// Checkbox to collect textures at export
		var wCollectTexturesCbx = new DzCheckBox( wSettingsDialog );
		wCollectTexturesCbx.text = "Collect Textures";
		wCollectTexturesCbx.checked = false;
		wSettingsDialog.addWidget( wCollectTexturesCbx );

		// Checkbox to include animation data
		var wIncludeAnimationsCbx = new DzCheckBox( wSettingsDialog );
		wIncludeAnimationsCbx.text = "Include animation data";
		wIncludeAnimationsCbx.checked = false;
		wSettingsDialog.addWidget( wIncludeAnimationsCbx );

		// Checkbox to include animation data
		var wRemoveIncompatible = new DzCheckBox( wSettingsDialog );
		wRemoveIncompatible.text = "Remove any incompatible nodes";
		wRemoveIncompatible.checked = false;
		wSettingsDialog.addWidget( wRemoveIncompatible );


		// Create Connections
		wChooseMorphsBut.released.connect( oNode, executeMorphDialog );

		// When user Cancels the dialog
		if( !wSettingsDialog.exec() ){
			return false;
		}
		
		// Set settings variables from the Dialog
		s_nSubDivLevel = wSubDivGroup.selected;
		s_bIncludeAnim = wIncludeAnimationsCbx.checked;
		s_bIncludeMorphs = wIncludeMorphsCbx.checked;
		s_bCollectTextures = wCollectTexturesCbx.checked;
		s_bRemoveIncompatible = wRemoveIncompatible.checked;

		// When user Accepts the dialog
		return true;
	};

	/*********************************************************************/
	// Bool : Executes Morph Dialog 
	function executeMorphDialog()
	{
		s_aExportableProperties = executeSubScript(
			s_sMorphDialog, 
			[this, s_sPresetPath, s_sDazBridgeName] 
		);
	};

	/*********************************************************************/
	// void : ...
	// No eyelashes on .OBJ
	function setEyelashVisibility( oBaseNode, bOnOff )
	{
		var oNode;
		
		var aHide = [ "Eyelashes", "Eye_1", "Eye_2", "_Shell" ];
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( oNode.getNodeParent() == oBaseNode ){
				for( var j = 0; j < aHide.length; j += 1 ){ 
					if( oNode.name.indexOf( aHide[j] ) > 0 ){
						oNode.setVisible( bOnOff );
					}
				}
			}
		}
	};

	/*********************************************************************/
	// string : ...
	function checkChildType( oChildNode )
	{
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oChildNode );
		return sContentType
	};

	/*********************************************************************/
	// TODO: Add a UI to allow the user to choose how they wish to export every asset
	// void : Check the node and what type of export it is. 
	function findRootNodes( oNode )
	{
		var oParent;
		var oOrgParent;
		var aChildFigures = [];
		var sClassName = oNode.className();
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oNode );
		if( sClassName == "DzFigure" 
		   || sClassName == "DzLegacyFigure" ){
			if( sContentType == "Actor/Character" 
				|| sContentType == "Actor" ){
				s_aFigures.push( oNode );
				return
			}
			else{
				s_aEnvProp.push( oNode );
				return
			}
		}
		if( sClassName == "DzGroupNode" ){
			aChildren = oNode.getNodeChildren( true );
			for( var j = 0; j < aChildren.length; j += 1 ){
				oChildNode = aChildren[j]
				sContentType = checkChildType( oChildNode );
				if( sContentType == "Actor/Character"
					|| sContentType == "Actor"){
					aChildFigures.push( oChildNode )
				}
			}
			if( aChildFigures.length > 0 ){
				for( var i = 0; i < aChildFigures.length; i++ ){
					var oChild = aChildFigures[i]
					s_aFigures.push( oChild )
					oParent = oChild.getNodeParent();
					if( oParent == oNode ){
						oNode.removeNodeChild( oChild, inPlace = true );
					}
					else{
						oOrgParent = oParent
						while( oParent != null ){
							oParent.removeNodeChild( oChild, inPlace = true );
							oParent = oChild.getNodeParent();
						}
						oParent = oOrgParent;
					}
					var aParentChain = new Array ( oParent, oChild );
					s_aToReparent.push( aParentChain );
				}
				return
			}
			else{
				s_aEnvProp.push( oNode );
				return
			}

		}
		else{
			s_aEnvProp.push( oNode );
			return
		} 
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - use oNode.assetUri instead of oNode.name
	function buildRootLists()
	{
		var oNode;
		var aChildren;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( !oNode.isVisible() ){
				if( oNode.isRootNode() ){ 
					oNode.setVisible( true );
					aChildren = oNode.getNodeChildren( true );
					for( var j = 0; j < aChildren.length; j += 1 ){
						aChildren[j].setVisible( true );
					}
				}
				continue;
			}
	
			if( oNode.isRootNode() && oNode.isVisible() ){
				findRootNodes( oNode )
			}
		}
	};
	/*********************************************************************/
	// void : ...
	function reparentFigure( oFigure )
	{
		var aPair
		for( var i = 0; i < s_aToReparent.length; i++ ){
			aPair = s_aToReparent[i]
			if( aPair[1] == oFigure ){
				aPair[0].addNodeChild( oFigure, inPlace = true)
				return
			}
		}
	}
	
	/*********************************************************************/
	// Number : ...
	function promptExportType()
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = "Select Export Type";
		
		var wLyt = new DzVBoxLayout( wDlg );
		wLyt.autoAdd = true;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		var aOptions = [ "Environment/Props", "Genesis8/3", "Both" ];
		for( var i = 0; i < aOptions.length; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = aOptions[i];
		}
		wOptBG.selected = s_oExportTypes.Figure;
		
		wDlg.addWidget( wOptBG );
		
		var oWidget = wDlg.getWidget();
		var sizeHint = oWidget.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 200 ? 200 : sizeHint.width;
		wDlg.setFixedSize( nWidth, nHeight );
		
		if( !wDlg.exec() ){
			return s_oExportTypes.None;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// Boolean : ...
	function isGenital( oNode )
	{
		var aKeys = [ "genital", "malegen_" ];
		if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
			return false;
		}
		
		var sName = oNode.name.toLowerCase();
		for( var i = 0; i < aKeys.length; i += 1 ){
			if( sName.length == 2 && sName == aKeys[i]
			|| sName.length > 2 && sName.indexOf( aKeys[i] ) >= 0 ){
				if( oNode.findNodeChild( "hip", false ) ){
					return true;
				}
			}
		}
		
		return false;
	};
	
	/*********************************************************************/
	// void : ...
	// Mesh consisting of only edges and points cannot be FBX transferred.
	// Even if it is invisible, it will be transferred, so there is no choice but to delete it.
	// Note: destructive - modifies the scene contents
	function removeIncompatibleNodes( oBaseNode )
	{
		var oNode;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		var aDelNodes = new Array( aNodes.length );
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( oNode.isRootNode() ){
				continue;
			}
			
			if( getMeshType( oNode ) == s_oMeshTypes.NoFacets ){
				aDelNodes[i] = oNode;
			}
		}
		
		aDelNodes = aDelNodes.filter( Boolean );
		
		for( var i = 0; i < aDelNodes.length; i += 1 ){
			oNode = aDelNodes[i];
			oBaseNode.removeNodeChild( oNode, true );
			oNode.setVisible( false );
			if( oNode.getLabel().endsWith( "dForce" ) ){
				Scene.removeNode( oNode );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function getMeshType( oNode )
	{
		if( !oNode ){
			return s_oMeshTypes.Other; //0
		}
		
		if( oNode.inherits( "DzBone" ) ){
			return s_oMeshTypes.Bone; //-1
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return s_oMeshTypes.Empty; //-3
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return s_oMeshTypes.Other; //0
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return s_oMeshTypes.Other; //0
		}
		
		var nFacets = oMesh.getNumFacets();
		if( nFacets < 1 && oMesh.name.toLowerCase().indexOf( "eyebrow" ) < 0 ){
			return s_oMeshTypes.NoFacets; //-2
		}
		
		if( nFacets > 14000 ){
			return s_oMeshTypes.Figure; //3
		}
		
		if( oNode.isRootNode() ){
			return s_oMeshTypes.Other; //0
		}
		
		return s_oMeshTypes.Mesh; //1
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : return success, error code, and/or message
	function writeDataFile( aData, sFilename )
	{
		var oFile = new DzFile( sFilename );
		if( !oFile.open( DzFile.WriteOnly ) ){
			print( String( "Unable to open \"%1\" for writing." ).arg( sFilename ) );
			
			return;
		}
		if (aData.constructor === Array){
			for( var i = 0; i < aData.length; i += 1 ){
				oFile.writeLine( aData[i] );
			}
		}	
		else{
			oFile.write( aData )
		}
			

		oFile.close();
	};
	
	/*********************************************************************/
	// void : ...
	// The mesh attached to the bone moves directly under the figure
	// Note: destructive - modifies the scene contents
	function flattenObjectHierarchy( oBaseNode )
	{
		var oChildLvl1;
		var vecChildLvl1Pos;
		var quatChildLvl1Rot;
		
		var aChildrenLvl2;
		var oChildLvl2;
		var vecChildLvl2Pos;
		var quatChildLvl2Rot;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			if( getMeshType( oChildLvl1 ) != s_oMeshTypes.Empty ){
				continue;
			}
			
			vecChildLvl1Pos = oChildLvl1.getLocalPos();
			quatChildLvl1Rot = oChildLvl1.getLocalRot();
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( true );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				vecChildLvl2Pos = oChildLvl2.getLocalPos();
				quatChildLvl2Rot = oChildLvl2.getLocalRot();
				
				vecChildLvl2Pos.x += vecChildLvl1Pos.x;
				vecChildLvl2Pos.y += vecChildLvl1Pos.y;
				vecChildLvl2Pos.z += vecChildLvl1Pos.z;
				
				quatChildLvl2Rot.x += quatChildLvl1Rot.x;
				quatChildLvl2Rot.y += quatChildLvl1Rot.y;
				quatChildLvl2Rot.z += quatChildLvl1Rot.z;
				
				oChildLvl2.setLocalPos( vecChildLvl2Pos );
				oChildLvl2.setLocalRot( quatChildLvl2Rot );
				
				oBaseNode.addNodeChild( oChildLvl2 );
			}
		}
	};
	
	/*********************************************************************/
	// Array<String> : ...
	function getParentingData( oParentNode, oBaseNode )
	{
		var aData = [];
		
		var oNode;
		var sName;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		aNodes.push( oBaseNode );
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
				continue;
			}
			
			sName = oNode.name;
			for( var j = 1; j <= 10; j += 1 ){
				if( !oNode.getLabel().endsWith( " (" + j + ")" ) ){
					continue;
				}
				
				sName += "_dup_" + j;
			}
			
			aData.push( oParentNode.name + "," + sName );
		}
		
		return aData;
	};
	
	/*********************************************************************/
	// void : ...
	function writeParentingData( oBaseNode, sFilename )
	{
		var aData = [];
		
		var oChildLvl1;
		
		var aChildrenLvl2;
		var oChildLvl2;
		
		var aChildrenLvl3;
		var oChildLvl3;
		
		var nMeshType;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( false );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				nMeshType = getMeshType( oChildLvl2 );
				//It's mesh(child)
				if( nMeshType > s_oMeshTypes.Other ){
					//Parent is bone
					if( getMeshType( oChildLvl1 ) == s_oMeshTypes.Bone ){
						aData = aData.concat( getParentingData( oChildLvl1, oChildLvl2 ) );
					}
				//It's Empty(Child)
				} else if( nMeshType == s_oMeshTypes.Empty ){
					aChildrenLvl3 = oChildLvl2.getNodeChildren( false );
					for( var k = 0; k < aChildrenLvl3.length; k += 1 ){
						oChildLvl3 = aChildrenLvl3[k];
						//Grandchild is mesh.
						//child's parent, parent child (sibling?) is bone
						if( getMeshType( oChildLvl3 ) > s_oMeshTypes.Other ){
							if( getMeshType( oChildLvl1.getNodeParent() ) == s_oMeshTypes.Bone ){
								aData = aData.concat( getParentingData( oChildLvl1, oChildLvl3 ) );
							}
						}
					}
				}
			}
		}
		
		if( aData.length > 0 ){
			writeDataFile( aData, sFilename );
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : remove - not used
	// Note: destructive - modifies the scene contents
	function lockNodeTransforms( oNode )
	{
		oNode.getToolXRotControl().lock( true );
		oNode.getToolYRotControl().lock( true );
		oNode.getToolZRotControl().lock( true );
		oNode.getOrientXControl().lock( true );
		oNode.getOrientYControl().lock( true );
		oNode.getOrientZControl().lock( true );
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : remove - not used
	function getTransformAsCSV( oNode, vecPos, mtxScale )
	{
		var sResult = vecPos.x + "," + vecPos.y + "," + vecPos.z + ",";
		
		sResult += oNode.getXRotControl().getLocalValue() + ",";
		sResult += oNode.getYRotControl().getLocalValue() + ",";
		sResult += oNode.getZRotControl().getLocalValue() + ",";
		
		sResult += mtxScale.m11 + "," + mtxScale.m22 + "," + mtxScale.m33;
		
		return sResult;
	};
	
	/*********************************************************************/
	// void : ...
	// Apply subdivision levels to figures and genitals.
	function setSubDivLevelAll( oBaseNode )
	{
		var bIsBody;
		var bIsGen;
		var nLev;
		var oNode;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			bIsBody = oNode == oBaseNode;
			bIsGen = !bIsBody && oNode.getNodeParent() == oBaseNode && isGenital( oNode );
			nLev = 0;
			if( bIsBody || bIsGen ){
				nLev = s_nSubDivLevel;
			}
			
			setSubDivLevel( oNode, nLev );
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setSubDivLevel( oNode, nLevel )
	{
		var aProps = [ "lodlevel", "SubDIALevel" ];
		var oObject = oNode.getObject();
		if( !oObject ){
			return;
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return;
		}
		
		var oProp;
		for( var i = 0; i < aProps.length; i += 1 ){
			oProp = oShape.findProperty( aProps[i] );
			if( oProp ){
				if( oProp.isLocked() ){
					oProp.lock( false );
				}
				
				if( i == 0 && nLevel == 0 ){
					oProp.setValue( "Basic" );
				} else {
					oProp.setValue( nLevel );
				}
				
				if( nLevel > 0 ){
					oProp.lock( true );
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setHideRoot( bIsFigure, bYesNo )
	{
		if( bIsFigure ){
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				setVisible( s_aFigures[i], bYesNo );
			}
		} else {
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				setVisible( s_aEnvProp[i], bYesNo );
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setVisible( oBaseNode, bYesNo )
	{
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			aChildren[i].setVisible( bYesNo );
		}
		
		oBaseNode.setVisible( bYesNo );
	};

	/*********************************************************************/
	// Number : Get the sign of the input number
	function getSign( nInput )
	{
		if( nInput >= 0 ){
			return 1;
		} else{
			return -1;
		}
	}

	/*********************************************************************/
	// Number : Get the direction of the bone's look at axis. 1 or -1
	function getLookAtDirection( oNode )
	{
		var vecLookAtAxis = oNode.getEndPoint().subtract( oNode.getOrigin() );
		
		var nSign = 1;
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nSign = getSign( vecLookAtAxis.x );
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nSign = getSign( vecLookAtAxis.y );
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nSign = getSign( vecLookAtAxis.z );
		}
		
		return nSign;
	};

	/*********************************************************************/
	// DzVec3 : Get the second axis of the node
	function getNodeSecondAxis( oNode )
	{
		var vecSecondAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().secondAxis == 0 ){
			vecSecondAxis.x = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 1 ){
			vecSecondAxis.y = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 2 ){
			vecSecondAxis.z = nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecSecondAxis = quatOrientation.multVec( vecSecondAxis );
		
		return vecSecondAxis;
	};

	/*********************************************************************/
	// DzVec3 : Get the primary axis of the node
	function getNodePrimaryAxis( oNode, nBoneLength )
	{
		var vecFirstAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		var nNodeScale = oNode.getScaleControl().getValue();
		
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nXScale = oNode.getXScaleControl().getValue();
			vecFirstAxis.x = nBoneLength * nSign * nXScale * nNodeScale;
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nYScale = oNode.getYScaleControl().getValue();
			vecFirstAxis.y = nBoneLength * nSign * nYScale * nNodeScale;
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nZScale = oNode.getZScaleControl().getValue();
			vecFirstAxis.z = nBoneLength * nSign * nZScale * nNodeScale;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecFirstAxis = quatOrientation.multVec( vecFirstAxis );
		
		return vecFirstAxis;
	};
	/*********************************************************************/
	// DzVec3 : Checks if there is an offset for Parent bone
	// TODO: Check if any other bones are changed with FBMs
	function getBoneOffset( oNode )
	{
		var vecOffset = new DzVec3( 0, 0, 0)
		for( var i = 0; i < oNode.getNumProperties(); i++ ){
			var oProperty = oNode.getProperty( i );
			var sPropName = oProperty.getName();
			// Currently only checking YTranslate
			if( sPropName == "YTranslate" ){
				var nControllerCount = oProperty.getNumControllers();
				for( var j = 0; j < nControllerCount; j += 1 ){
					var oErcLink = new DzERCLink();
					oErcLink = oProperty.getController( j );
					var oControllerProp = oErcLink.getProperty();
					sControllerName = getPropertyName(oControllerProp);
					if( oControllerProp.getDoubleValue() != 0 ){
						vecOffset.y += oErcLink.scalar * oControllerProp.getDoubleValue();
					};
					
				};
			};
		};
		return vecOffset
	};
	
	/*********************************************************************/
	// Float : Get length of the bone
	function getBoneNodeLength( oNode )
	{
		var vecAlongBone = oNode.getEndPoint().subtract( oNode.getOrigin() );
		return vecAlongBone.length();
	}

	/*********************************************************************/
	// Void : load bone's limits along with rotation orders
	function loadFigureBoneData( oBaseNode )
	{

		if( !oBaseNode.inherits( "DzFigure" ) ){
			if( !oBaseNode.inherits( "DzLegacyFigure" ) ){
				return;
			}
		}
		var oSkeleton = oBaseNode.getSkeleton();
		var aNodes = oSkeleton.getAllBones();
		var numFollowers = oSkeleton.getNumFollowSkeletons();
		var oFollowSkeleton;
		var aFollowNodes;
		var oFollowNode;
		var bIsNewNode;
		
		// Collect followers' bones that does not exist in the main skeleton
		for( var i = 0; i < numFollowers; i += 1 ){
			oFollowSkeleton = oSkeleton.getFollowSkeleton( i );
			aFollowNodes = oFollowSkeleton.getAllBones();
			for( var j = 0; j < aFollowNodes.length; j += 1 ){
				oFollowNode = aFollowNodes[j];
				bIsNewNode = false;
				for( var k = 0; k < aNodes.length; k += 1 ){
					if( oFollowNode.name == aNodes[k].name ){
						bIsNewNode = true;
						break;
					}
				}

				if( bIsNewNode == false ){
					aNodes = aNodes.concat( aFollowNodes[j] );
				}
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes == 0 ){
			return;
		}
		
		var oNode;
		var sRotOrder;
		var nXRotMin;
		var nXRotMax;
		var nYRotMin;
		var nYRotMax;
		var nZRotMin;
		var nZRotMax;
		var nXOrientation;
		var nYOrientation;
		var nZOrientation;
		var vecOffset;
		
		// To account for the scale on the skeleton due to morphs
		var nSkeletonScale = oBaseNode.getScaleControl().getValue();
		s_oSkeletonData["skeletonScale"] = ["skeletonScale", nSkeletonScale];
		// To account for offset on the hip bone.
		vecOffset = getBoneOffset(aNodes[0])
		s_oSkeletonData["offset"] = ["offset", vecOffset.y];

		oBaseNode.update();
		oBaseNode.finalize();
		var oFigure = new DzFigure();
		
		var oFigure = oBaseNode.getSkeleton();
		if ( oBaseNode.className() != "DzLegacyFigure" ){
			var oSkinBinding = oFigure.getSkinBinding();
		}
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			
			sRotOrder = oNode.getRotationOrder().toString();
			nXRotMin = oNode.getXRotControl().getMin();
			nXRotMax = oNode.getXRotControl().getMax();
			nYRotMin = oNode.getYRotControl().getMin();
			nYRotMax = oNode.getYRotControl().getMax();
			nZRotMin = oNode.getZRotControl().getMin();
			nZRotMax = oNode.getZRotControl().getMax();
			nXOrientation = oNode.getOrientXControl().getValue();
			nYOrientation = oNode.getOrientYControl().getValue();
			nZOrientation = oNode.getOrientZControl().getValue();
			quatOrientation = oNode.getOrientation();

			s_oLimitsData[oNode.getName()] = [
				oNode.getName(),
				sRotOrder,
				nXRotMin, nXRotMax,
				nYRotMin, nYRotMax,
				nZRotMin, nZRotMax
				];

			nBoneLength = getBoneNodeLength( oNode );
			vecPrimaryAxis = getNodePrimaryAxis( oNode, nBoneLength );

			vecHead = oNode.getOrigin( false );
			if ( oBaseNode.className() != "DzLegacyFigure" ){
				oBoneBinding = oSkinBinding.findBoneBinding( oNode );
				if( oBoneBinding ){
					vecHead = oBoneBinding.getScaledOrigin();
				}
			}
			
			vecTail = vecHead.add( vecPrimaryAxis );
			vecSecondAxis = getNodeSecondAxis( oNode );
			
			s_oHeadTailData[oNode.getName()] = [
				( vecHead.x + vecOffset.x ) * nSkeletonScale,
				( vecHead.y + vecOffset.y ) * nSkeletonScale,
				( vecHead.z + vecOffset.z ) * nSkeletonScale,
				( vecTail.x + vecOffset.x ) * nSkeletonScale,
				( vecTail.y + vecOffset.y ) * nSkeletonScale,
				( vecTail.z + vecOffset.z ) * nSkeletonScale,
				vecSecondAxis.x,
				vecSecondAxis.y,
				vecSecondAxis.z
				]
				.concat( getBoneTransformValues( oNode ) );

			s_oJointOrientation[oNode.getName()] = [
				sRotOrder,
				nXOrientation,
				nYOrientation,
				nZOrientation,
				quatOrientation.w,
				quatOrientation.x,
				quatOrientation.y,
				quatOrientation.z
			]
			
		}
	};
	
	/*********************************************************************/	
	// void : ...
	// Note: Configure DTU File
	// TO DO: Grab Subdivision info and Morphs Exporting
	function writeConfiguration( oNode, sFilename, sDir )
	{
		var sDtufilename = sFilename + ".dtu";
		var oDtufile = new DzFile( sDtufilename );
		var oDtuJson = {};
		var aChildren = oNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oNode );
		
		oDtuJson["Asset Name"] = oNode.getLabel();
		oDtuJson["Import Name"] = oNode.getName();
		oDtuJson["Asset Type"] = sContentType;
		oDtuJson["FBX File"] = s_sFbxPath;
		oDtuJson["Materials"] = [];
		oDtuJson["MorphLinks"] = s_oMorphLinks;
		oDtuJson["MorphNames"] = s_aMorphNamesToExport;
		oDtuJson["SkeletonData"] = s_oSkeletonData;
		oDtuJson["HeadTailData"] = s_oHeadTailData;
		oDtuJson["JointOrientation"] = s_oJointOrientation;
		oDtuJson["LimitData"] = s_oLimitsData;
		oDtuJson["PoseData"] = s_oPoseData;
		oDtuJson["Subdivision"] = s_nSubDivLevel;
		
		aFigureMats = writeMaterials( oNode, sDir );
		oDtuJson["Materials"].push( aFigureMats );
		if (nChildren > 0){
			for ( var i = 0; i < nChildren; i++ ){
				var oChild = aChildren[ i ]; 
				aChildMats = writeMaterials( oChild, sDir );
				if ( aChildMats != false ){
					oDtuJson["Materials"].push( aChildMats );
				}		
			}
		};
		
		function combineMaterials( key, value ){
			var aNewMaterials = [];
			if( key == "Materials" ){
				for (var i=0; i < value.length; i++ ){
					var aNodeMats = value[i];
					for (var k=0; k < aNodeMats.length; k++ ){
						var aMat = aNodeMats[k];
						aNewMaterials.push( aMat );
					}
				}
				return aNewMaterials;
			}
			else{
				return value;
			}
		};
		
		oDtufile.open( DzFile.WriteOnly );
		oDtufile.write( JSON.stringify( oDtuJson, combineMaterials, 4 ) );
		oDtufile.close();
	};
	/*********************************************************************/
	// String : Writes Texture and returns new Path
	// TODO: Find a better method to get the paths
	function writeTexture( sDir, sOrigTexture, sAssetName )
	{
		var oOrigFile = new DzFile( sOrigTexture );
		var sOrgImageName = oOrigFile.fileName();
		var sAbsPath = oOrigFile.absolutePath();
		var aSplitPath = sAbsPath.split("Textures");
		var sPath = String( "%1/%2/%3" ).arg( sDir ).arg( "Textures" ).arg( sAssetName );
		
		var oDir = new DzDir( "" );
		oDir.setPath( sPath );
		if( !oDir.exists() ){
			oDir.mkpath( sPath );
		}
		oDir.setPath( s_sRootPath )

		var sNewTexture = String( "%1/%2" ).arg( sPath ).arg( sOrgImageName )
		var sRelTexture = oDir.relativeFilePath( sNewTexture )
		oOrigFile.copy( sNewTexture )
		return sRelTexture
		
	};


	/*********************************************************************/	
	// Array : ...
	// Note: Cycle through all the Materials on a Node and return an array
	function writeMaterials( oNode, sDir )
	{	
		var oObj = oNode.getObject();
		if( oObj != null ){
			var oShape = oObj.getCurrentShape();
			var aMaterials = [];
			if( oShape ){
				for( var k = 0; k < oShape.getNumMaterials(); k++ ){
					var oMaterialInfo = {};
					var aProperties = [];
					var oMat = oShape.getMaterial( k );
					if( oMat ){	
						oMaterialInfo["Asset Name"] = oNode.name;
						oMaterialInfo["Asset Label"] = oNode.getLabel();
						oMaterialInfo["Material Name"] = oMat.getName();
						oMaterialInfo["Material Type"] = oMat.getMaterialName();
						
						// Get presentation and set material info
						var oPresentation = oNode.getPresentation();
						if( oPresentation != undefined ){
							var sPresentationType = oPresentation.type
							oMaterialInfo["Value"]  = sPresentationType;
						}
						else{
							oMaterialInfo["Value"]  = "Unknown";
						}

						// Load all the porperties info
						for( var i = 0; i < oMat.getNumProperties(); i++ ){
							var oProperty = oMat.getProperty( i );
							var oPropertyInfo = {};
							
							oPropertyInfo["Name"] = oProperty.getName();
							oPropertyInfo["Label"] = oProperty.getLabel();
							
							var bImageProperty = oProperty.inherits( "DzImageProperty" );
							var bColorProperty = oProperty.inherits( "DzColorProperty" );
							var bNumericProperty = oProperty.inherits( "DzNumericProperty" );
							var sTextureName = "";

							if( bImageProperty ){
								if(oProperty.getValue()){
									sTextureName = oProperty.getValue().getFilename();	
								}
								oPropertyInfo["Value"] = oMat.getDiffuseColor().name;
								oPropertyInfo["Data Type"] = "Texture";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bColorProperty ){
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getColorValue().name;
								oPropertyInfo["Data Type"] = "Color";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bNumericProperty ){
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getValue();
								oPropertyInfo["Data Type"] = "Double";
								oPropertyInfo["Texture"] = sTextureName;
							}
							aProperties.push( oPropertyInfo );
							if ( sTextureName != "" ){
								if(s_bCollectTextures){
									sNewTexture = writeTexture( sDir, 
																sTextureName,
																oMaterialInfo["Asset Label"]);
									oPropertyInfo["Texture"] = sNewTexture;
								}
							}
						}
						oMaterialInfo["Properties"] = aProperties;
						
						aMaterials.push( oMaterialInfo );
					}
				}						
			}
			return aMaterials
		}
		else{
			return false
		}
	};

	/*********************************************************************/
	// String : Get the name of the Property
	function getPropertyName( oProperty )
	{
		var sPropertyName = oProperty.name;
		var oOwnerProperty = oProperty.getOwner();
		if( oOwnerProperty.inherits( "DzMorph" ) ){
			sPropertyName = oOwnerProperty.name;
		}
		return sPropertyName;
	};

	/*********************************************************************/
	// String : Returns the morph rules to be used at Export
	function getMorphString( aExportableProperties ) 
	{
        var sMorphString

        if ( aExportableProperties.length == 0 ){
            return "";
        }
        s_aMorphNamesToExport = [];
        sMorphString = "";
        for( var i = 0; i < aExportableProperties.length; i++ ){
            oMorphInfo = aExportableProperties[i]
            s_aMorphNamesToExport.push( oMorphInfo.name );
        }
        sMorphString = s_aMorphNamesToExport.join("\n1\n");
        sMorphString += "\n1\n.CTRLVS\n2\nAnything\n0";
        return sMorphString;
    };
	
	/*********************************************************************/
	// Object : Returns the Keyed Data
	function getErcKeyed( oErc, nIdx )
	{
		var oKey = {}
		oKey["Rotate"] = oErc.getKey( nIdx );
		oKey["Value"] = oErc.getKeyValue( nIdx );
		
		return oKey
	};

	/*********************************************************************/
	// Array : Find if Morph Exists on Children, Useful for FACS
	function checkForMorphOnChild( oNode, aControlledMeshes, sMorphName )
	{
		for ( var i = 0; i < oNode.getNumNodeChildren(); i++ ){
			oChildNode = oNode.getNodeChild( i );
			if( oChildNode.inherits( "DzFigure" ) ){
				oObject = oChildNode.getObject();
				if( oObject ){
					oModifer = oObject.findModifier( sMorphName );
					if( oModifer ){
						aControlledMeshes.pushIfNotExists( oChildNode.name + ".Shape" );
					}
				}
			}
		}
		return aControlledMeshes

	}
	/*********************************************************************/
	// Array : Find if Bone Exists on Children Objects
	// Check if Bone has skin weights on object
	function checkForBoneInChild( oNode, sBoneName, aControlledMeshes )
	{
		for ( var i = 0; i < oNode.getNumNodeChildren(); i++ ){
			oChildNode = oNode.getNodeChild( i );
			if( oChildNode.inherits( "DzFigure" ) ){
				oSkeleton = oChildNode.getSkeleton();
				oChildBone = oSkeleton.findBone( sBoneName );
				if( !oChildBone ){
					continue
				}
				// get the weight map Handler
				var oWeightMapHandler = oSkeleton.getWeightMapHandler();
				var oSkinBinding= oWeightMapHandler.getSkinBinding();	
				var oBoneBinding = oSkinBinding.findBoneBinding( sBoneName );    
				if( oBoneBinding ){
					aControlledMeshes.pushIfNotExists( oChildNode.name + ".Shape" );
				}
			}
		}
		return aControlledMeshes
	};

	/*********************************************************************/
	// Array : Check the alias of the morph to find the bone
	function checkForBoneInAlias( oNode, oMorphProperty, aControlledMeshes )
	{
		for( var l = 0; l < oMorphProperty.getNumAliases(); l++ ){
			var oAlias = oMorphProperty.getAlias( l );
			var oBone = oAlias.getOwner();
			var sBoneName;
			if( oBone.inherits("DzBone") ){
				sBoneName = oBone.name;
				aControlledMeshes = checkForBoneInChild( oNode, sBoneName, aControlledMeshes );
			}
		}
		return aControlledMeshes
	}
	
	/*********************************************************************/
	// Array : Check the bone being controled by the morphs
	function checkMorphControlsChildren( oNode, oMorphProperty )
	{
		var aControlledMeshes = [];
		var sBoneName;
		var oOwnerNode;
		var oSlaveControler;

		aControlledMeshes.push(oNode.name + ".Shape");
		var nSlaveControllerCount = oMorphProperty.getNumSlaveControllers();
		for( var j = 0; j < nSlaveControllerCount; j ++ ){
			oSlaveControler = oMorphProperty.getSlaveController( j );
			oOwnerNode = oSlaveControler.getOwner();
			if( oOwnerNode ){
				oOwnerNode = oOwnerNode.getOwner();
				if( oOwnerNode.inherits( "DzBone" ) ){
					sBoneName = oOwnerNode.name;
					aControlledMeshes = checkForBoneInChild( oNode, sBoneName, aControlledMeshes );
					break
				}	
			}		
		}
		if( !sBoneName ){
			aControlledMeshes = checkForBoneInAlias( oNode, oMorphProperty, aControlledMeshes )
		}	
		return aControlledMeshes
	};

	/*********************************************************************/
	// Void : Load morph links that are directly controlled by skeleton bones
	function loadMorphLinks( aExportableProperties, oNode )
	{
		// Load all the controller links on the properties
		for( var i = 0; i < aExportableProperties.length; i += 1 ){
			var oMorphInfo = aExportableProperties[i]
			var oMorphProperty = oMorphInfo.property;
			var nControllerCount = oMorphProperty.getNumControllers();
			var aLinks = [];
			var aSubLinks = []
			var sBoneName;
			var oOwnerNode;

			// Keep Morphs that are control bone placement 
			var aControlledMeshes = checkMorphControlsChildren( oNode, oMorphProperty );
			// Keep for the Children Nodes' Morphs
			var oMorphInfoNode = oMorphInfo.node;
			if( oMorphInfoNode != undefined ){
				if( oMorphInfoNode.name != oNode.name ){
					aControlledMeshes.pushIfNotExists( oMorphInfo.node.name + ".Shape" );
				}
			}
			// Check if Morph has its own version on Children
			aControlledMeshes = checkForMorphOnChild( oNode, aControlledMeshes, oMorphInfo.name )
			
			for( var j = 0; j < nControllerCount; j += 1 ){
				var oErcLink = new DzERCLink();
				oErcLink = oMorphProperty.getController( j );
				var oControllerProp = oErcLink.getProperty();
				
				var oLink = {
					"Bone": "None",
					"Property": getPropertyName( oControllerProp ),
					"Type": oErcLink.type,
					"Scalar": oErcLink.scalar,
					"Addend": oErcLink.addend,
					
				};
				if( oErcLink.type == 6 ){
					oLink["Key Type"] = oErcLink.keyInterpolation;
					var oKeys = {}
					for( var k = 0; k < oErcLink.getNumKeyValues(); k++ ){
						oKey = getErcKeyed( oErcLink, k );
						
						sKey = String( "%1 %2" ).arg( "Key" ).arg( k );
						oKeys[sKey] = oKey;
					}
					oLink["Keys"] = oKeys;
				}
				oOwnerNode = oControllerProp.getOwner();
				if( oOwnerNode.inherits( "DzBone" ) ){
					sBoneName = oOwnerNode.name 
					aControlledMeshes = checkForBoneInChild( oNode, sBoneName, aControlledMeshes )
					oLink["Bone"] = oOwnerNode.name
				}
				aLinks.push( oLink );
			}

			var nSlaveControllerCount = oMorphProperty.getNumSlaveControllers();
			for( var j = 0; j < nSlaveControllerCount; j ++ ){
				var oErcLink = new DzERCLink()
				oErcLink = oMorphProperty.getSlaveController( j );
				oOwnerNode = oErcLink.getOwner();
				if ( oOwnerNode ){
					oBoneNode = oOwnerNode.getOwner();
					if( oBoneNode.inherits( "DzBone" ) ){
						var oLink = {
							"Bone": oBoneNode.name,
							"Property": oOwnerNode.name,
							"Type": oErcLink.type,
							"Scalar": oErcLink.scalar,
							"Addend": oErcLink.addend,
							
						};
						aSubLinks.push( oLink );
					}	
				}
					
			}

			var oMorphLinkObj = {
					"Label": oMorphProperty.getLabel(),
					"Links": aLinks,
					"SubLinks" : aSubLinks,
					"Minimum": oMorphInfo.min,
					"Maximum": oMorphInfo.max,
					"isHidden": oMorphInfo.hidden,
					"Path": oMorphInfo.path,
					"Controlled Meshes" : aControlledMeshes
			};
			s_oMorphLinks[getPropertyName( oMorphProperty )] = oMorphLinkObj;
		}
		
		return;		
	};
	/*********************************************************************/
	// Void: ...
	function disconnectMorphs( aExportableProperties )
	{
		for( var i = 0; i < aExportableProperties.length; i += 1 ){
			var oMorphInfo = aExportableProperties[i]
			var oMorphProperty = oMorphInfo.property;
			
			if( oMorphInfo.disable == true){
				oMorphProperty.setValue( 0 );
				oMorphProperty.setOverrideControllers( true );
			}
		}
	}
	
	/*********************************************************************/
	// Void: ...
	function reconnectMorphs( aExportableProperties )
	{
		for( var i = 0; i < aExportableProperties.length; i += 1 ){
			var oMorphInfo = aExportableProperties[i]
			var oMorphProperty = oMorphInfo.property;
			if( oMorphInfo.disable ){
				oMorphProperty.setOverrideControllers( false );
				oMorphProperty.setValue( oMorphInfo.value );
			}
		}
	}

	/*********************************************************************/
	// Void: ...
	function disconnectSkeleton( oNode )
	{
		if( oNode.inherits( "DzSkeleton" ) ){
			var oSkeleton = oNode.getSkeleton();
			var aNodes = oSkeleton.getAllBones();
			for( var i = 0; i < aNodes.length; i += 1 ){
				var oBoneNode = aNodes[i]
				oXpos = oBoneNode.getXPosControl();	
				oXrot = oBoneNode.getXRotControl();
				oYpos = oBoneNode.getYPosControl();
				oYrot = oBoneNode.getYRotControl();
				oZpos = oBoneNode.getZPosControl();
				oZrot = oBoneNode.getZRotControl();
				s_oSkeletonTransforms[oBoneNode.name] = {}
				aProperties = [oXpos, oXrot, oYpos, oYrot, oZpos, oZrot];
				for( var j = 0; j < aProperties.length; j += 1 ){
					var oProperty = aProperties[j]
					s_oSkeletonTransforms[oBoneNode.name][oProperty.assetId] = oProperty.getValue();
					oProperty.setOverrideControllers( true );
				}
			}
		}
		
	}
	
	/*********************************************************************/
	// Void: ...
	function reconnectSkeleton( oNode )
	{
		if( oNode.inherits( "DzSkeleton" ) ){
			var oSkeleton = oNode.getSkeleton();
			var aNodes = oSkeleton.getAllBones();
			var oAssetMgr = App.getAssetMgr();
			for( var i = 0; i < aNodes.length; i += 1 ){
				var oBoneNode = aNodes[i]
				oXpos = oBoneNode.getXPosControl();	
				oXrot = oBoneNode.getXRotControl();
				oYpos = oBoneNode.getYPosControl();
				oYrot = oBoneNode.getYRotControl();
				oZpos = oBoneNode.getZPosControl();
				oZrot = oBoneNode.getZRotControl();

				aProperties = [oXpos, oXrot, oYpos, oYrot, oZpos, oZrot,];
				for( var j = 0; j < aProperties.length; j += 1 ){
					var oProperty = aProperties[j]
					oProperty.setOverrideControllers( false );
					oProperty.setValue( s_oSkeletonTransforms[oBoneNode.name][oProperty.assetId] );
				}
			}
		}
	}

	/*********************************************************************/

	// void : ...
	function main()
	{
		var bDebugFBX = false;
		
		buildRootLists();
		
		if( s_aFigures.length > 2 ){
			if( MessageBox.warning(
				qsTr( "Transferring 3 or more figures with clothing or hair may freeze and stop." ),
				s_sToolName, qsTr( "&OK" ), qsTr( "&Cancel" ) ) == 1 ){
				return;
			}
		}
		
		if( s_aFigures.length == 0 && s_aEnvProp.length == 0 ){
			return;
		} else if( s_aFigures.length > 0 && s_aEnvProp.length > 0 ){
			s_nExportType = s_oExportTypes.Both;
		} else if( s_aEnvProp.length == 0 ){
			s_nExportType = s_oExportTypes.Figure;
		} else if( s_aFigures.length == 0 ){
			s_nExportType = s_oExportTypes.EnvProp;
		}
		
		if( s_nExportType == s_oExportTypes.Both ){
			s_nExportType = promptExportType();
		}
		
		if( s_nExportType == s_oExportTypes.None ){
			return;
		}
		
		prepareForExport( s_nExportType );
		
		var sFileBasename;
		var sBaseDirectory; 

		if( s_nExportType == s_oExportTypes.Both
		|| s_nExportType == s_oExportTypes.Figure ){
			setHideRoot( false, false );
			
			var oFigure;
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				oFigure = s_aFigures[i];
				for( var j = 0; j < s_aFigures.length; j += 1 ){
					setVisible( s_aFigures[j], i == j );
				}
				
				if( !promptSettings( oFigure ) ){
					continue;
				}
				
				setLock( oFigure, true, true );
				makeEndDir( i, s_sFig );
				setSubDivLevelAll( oFigure );
				
				// Morph Export
				if( s_bIncludeMorphs ){
					s_sMorphRules = getMorphString( s_aExportableProperties );
					loadMorphLinks( s_aExportableProperties, oFigure );
					disconnectMorphs( s_aExportableProperties );
					// disconnectSkeleton( oFigure );
				};	
				// Export Figure
				loadFigureBoneData( oFigure );
				loadPoseData( oFigure, true );
				setEyelashVisibility( oFigure, false );
				exportOBJ( oFigure, s_sFig, i );
				setEyelashVisibility( oFigure, true );
				if( s_bRemoveIncompatible ){
					removeIncompatibleNodes( oFigure );
				}
				exportFBX( oFigure, s_sFig, i , bDebugFBX );
				setLock( oFigure, false, true );
				restorePose( oFigure );
				reparentFigure( oFigure );
				if ( s_bIncludeMorphs ){
					reconnectMorphs( s_aExportableProperties );
					// reconnectSkeleton( oFigure );
				}

				// Write data
				sFileBasename = String( "%1%2/%2%3/%2" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				sBaseDirectory = String( "%1%2/%2%3" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				writeParentingData( oFigure, sFileBasename + ".dat" );
				writeConfiguration( oFigure, sFileBasename, sBaseDirectory );

			}
		}
		
		if( s_nExportType != s_oExportTypes.Figure ){
			setHideRoot( true, false );
			
			var oNode;
			var bIsBone;
			var sEnvPath;
			var sPoseFilename;
			var sFileBasename;
			
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				oNode = s_aEnvProp[i];

				for( var j = 0; j < s_aEnvProp.length; j += 1 ){
					setVisible( s_aEnvProp[j], i == j );
				}
				
				bIsBone = oNode.getSkeleton() != null;
				if( bIsBone ){
					flattenObjectHierarchy( oNode );
				}
				else{
					setLock( oNode, true, false );
				}
				
				
				setSubDivLevelAll( oNode, 0 );
				
				sEnvPath = String( "%1%2/%2%3/" ).arg( s_sRootPath ).arg( s_sEnv ).arg( i );
				makeEndDir( i, s_sEnv );
				
				if( oNode.name.startsWith( "Genesis" ) ){
					applyDefaultTransforms( oNode );
				}
				
				updateName( oNode );
				
				exportFBX( oNode, s_sEnv, i, bDebugFBX );
				
				sFileBasename = sEnvPath + s_sEnv;
				sPoseFilename = sFileBasename + ".transforms";
				
				if( bIsBone ){
					loadFigureBoneData( oNode );
					loadPoseData( oNode, true );
				} else {
					loadPoseData( oNode, false );
					writeMemo( sEnvPath + "nobone.txt", "not skeleton" );
					setLock( oNode, false, false );
				}
				updateName( oNode );
				
				writeConfiguration( oNode, sFileBasename );

				
			}
		}
		
		setHideRoot( true, true );
		setHideRoot( false, true );
	};
	
	/*********************************************************************/
	main();

})();