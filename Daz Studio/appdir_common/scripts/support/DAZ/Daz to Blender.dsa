// DAZ Studio version 4.12.0.86 filetype DAZ Script

(function(){
	
	var s_oFileInfo = new DzFileInfo( getScriptFileName() );
	var s_sToolName = s_oFileInfo.baseName();
	s_oFileInfo.deleteLater();
	
	var s_aFigures = [];
	var s_aEnvProp = [];
	
	var s_sFig = "FIG";
	var s_sEnv = "ENV";
	
	var s_oMeshTypes = {
		"Figure" :3,
		"Mesh" : 1,
		"Other" : 0,
		"Bone" : -1,
		"NoFacets" : -2,
		"Empty" : -3
	};
	
	var s_oExportTypes = {
		"Both" : 2,
		"Figure" : 1,
		"EnvProp" : 0,
		"None" : -1
	};
	var s_nExportType = s_oExportTypes.None;
	
	var s_sMorphRules = "";
	var s_aMorphExported = [];
	var s_sRootPath = "";
	
	var s_oMorphs = {};
	var s_aSearch = [];
	var s_nLenName = 0;
	var s_nMaxName = 19;
	var s_nMaxAll = 63;
	var s_s3Spaces = "   ";
	var s_sAlf = "1234567890abcdefghijklmnopqrstuvwxyz";
	
	var s_vecDef = new DzVec3( 0, 0, 0 );
	var s_quatDef = new DzQuat( 0, 0, 0, 1, true );
	var s_mtxDef = new DzMatrix3( s_quatDef );
	
	var s_aPoseData = [];
	
	/*********************************************************************/
	// void : ...
	// Note: destructive - modifies the scene contents
	// TODO: Redo Morph export need to give users a choice
	function buildMorphList( oNode )
	{
		if( oNode.inherits( "DzFigure" ) ){
            oNode = oNode.getSkeleton();
			var aProperties = getElementProperties( oNode, true, true );
        }    
		else{
			var aProperties = getElementProperties( oNode, true, true );
		}
		var nAlfIdx = 0;
		var aTops = [ "Morphs", "Hidden", "Pose" ];
		
		var oProp;
		var oOwner;
		var oTop;
		var sPath;
		var sHead;
		var sLabel;
		var sTmp;
		
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProp = aProperties[i];
			oOwner = oProp.getOwner();
			sPath = oProp.getPath();
			sHead = "";

			for( var j = 0; j < aTops.length; j += 1 ){
				oTop = aTops[j];
				if( sPath.indexOf( "/" + oTop ) == 0 ){
					sHead = "<" + oTop + ">";
					break;
				}
			}
			
			if( sHead.isEmpty() ){
				continue;
			}
				
			sLabel = oProp.getLabel();
			if( ( sLabel.length + 2 + s_nMaxName ) > s_nMaxAll ){
				sLabel = sLabel.slice( 0, s_nMaxAll - s_nMaxName - 2 - 2 );
				sLabel = sLabel + "_" + s_sAlf.substr( nAlfIdx, 1 );
				oOwner.name = sLabel;
				nAlfIdx += 1;
				nAlfIdx = nAlfIdx % 36;
			}
			
			sName = oProp.getName()
			s_oMorphs[sLabel] = {
								"sMorphHead": sHead, 
								"sMorphName" : sName, 
								"sMorphPath" : sPath
								};
		}
	};
	
	
// --- START node_properties ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/properties/node_properties/start
 	
 	// - Extraccted functions
 	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting a list of the properties in a group
	function getGroupProperties( oGroup, bTraverse, bRecurse )
	{
		// Declare an array to hold properties
		var aProperties = [];
		
		// If a group is not passed in
		if( !oGroup ){
			// We are done, return an empty array
			return aProperties;
		}
		
		// Get the number of proeprties in the group
		var nProperties = oGroup.getNumProperties();
		// Pre-size the properties array
		aProperties = new Array( nProperties );
		// Iterate over the properties, setting each element in the array
		for( var i = 0; i < nProperties; i += 1 ){
			// Assign the property to the position in the array
			aProperties[ i ] = oGroup.getProperty( i );
		}
		
		// If we are recursing
		if( bRecurse ){
			// Concatenate the properties array from child groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getFirstChild(), true, bRecurse ) );
		}
		
		// If we are traversing
		if( bTraverse ){
			// Concatenate the properties array from sibling groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getNextSibling(), bTraverse, bRecurse ) );
		}
 		
		// Return the array of properties
		return aProperties;
	};
	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting the list properties for an element
	function getElementProperties( oElement, bTraverse, bRecurse )
	{
		// Get the property group tree for the element
		var oPropertyGroupTree = oElement.getPropertyGroups();
		
		// If the application version is 4.9.4.101 or newer and we want all properties
		if( App.version64 >= 0x0004000900040065 && bTraverse && bRecurse ){
			// Return the properties for the element
			return oPropertyGroupTree.getAllProperties();
		}
		
		// Get the first group in the tree
		var oPropertyGroup = oPropertyGroupTree.getFirstChild();
		// Return the properties for the element
		return getGroupProperties( oPropertyGroup, bTraverse, bRecurse );
	};
	
// --- END node_properties ----
	
	
// --- START export_fbx_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_fbx_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportFBX( oNode, sName, nIdx, bAscii )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Autodesk Filmbox (*.fbx) exporter
		var sClassName = "DzFbxExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Selected
			oSettings.setBoolValue( "doSelected", false );
			// No Hidden
			oSettings.setBoolValue( "doVisible", true );
			// Figures
			oSettings.setBoolValue( "doFigures", true );
			
			var bIsEnv = sName.startsWith( s_sEnv );
			// Props
			oSettings.setBoolValue( "doProps", bIsEnv );
			// Lights
			oSettings.setBoolValue( "doLights", bIsEnv );
			// Cameras
			oSettings.setBoolValue( "doCameras", bIsEnv );
			
			// Animations
			oSettings.setBoolValue( "doAnims", true );
			// Morphs
			oSettings.setBoolValue( "doMorphs", true );
			
			// Fps
			oSettings.setBoolValue( "doFps", true );
			
			// Morph Rules
			// Format for rules is "Match1\nAction1\nMatch2\nAction2\nMatch3\nAction3",
			// where Match# is a string to search for and Action# is one of Bake|Export|Ignore
			// The names of the morphs are in the form: node_name.parameter_name
			// The default action is to Bake
			// So "FBMHeavy\nExport\nThin\nExport" would export all morphs that have FBMHeavy and all morphs that have Thin in the name
			oSettings.setStringValue( "rules", s_sMorphRules );
			
			// Format
			// Format for format is "Year# -- Type",
			// where Year# is one of 2006|2009|2010|2011|2012|2013|2014 and
			// Type is one of Ascii|Binary
			if( bAscii ){
				oSettings.setStringValue( "format", "FBX 2014 -- Ascii" );
			} else {
				oSettings.setStringValue( "format", "FBX 2014 -- Binary" );
			}
			
			// Embed Textures
			oSettings.setBoolValue( "doEmbed", false );
			// Collect Textures To Folder
			oSettings.setBoolValue( "doCopyTextures", false );
			// Merge Diffuse and Opacity Textures
			oSettings.setBoolValue( "doDiffuseOpacity", false );
			// Merge Clothing Into Figure Skeleton
			oSettings.setBoolValue( "doMergeClothing", true );
			// Convert Clothing to Static Geometry
			oSettings.setBoolValue( "doStaticClothing", false );
			// Allow Degraded Skinning
			oSettings.setBoolValue( "degradedSkinning", false );
			// Allow Degraded Scaling
			oSettings.setBoolValue( "degradedScaling", false );
			// SubD Information
			oSettings.setBoolValue( "doSubD", false );
			// Collapse UV Tiles
			//oSettings.setBoolValue( "doCollapseUVTiles", false );
			
			oSettings.setBoolValue( "doLocks", false );
			oSettings.setBoolValue( "doLimits", false );
			oSettings.setBoolValue( "doBaseFigurePoseOnly", false );
			oSettings.setBoolValue( "doHelperScriptScripts", false );
			oSettings.setBoolValue( "doMentalRayMaterials", false );
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Define whether or not to show the options after prompting for a file;
				// prior to 4.9.3.22 this exporter ignored this option entirely,
				// running silent was implied by virtue of being run via script
				oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			}
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/";
			if( bAscii ){
				sPath += "A_" + sName + ".fbx"
			} else {
				sPath += "B_" + sName + ".fbx"
			}
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_fbx_silent ----
	
	
// --- START export_obj_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_obj_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportOBJ( oNode, sName, nIdx )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Wavefront Object (*.obj) exporter
		var sClassName = "DzObjExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Set the scale to write the data
			oSettings.setFloatValue( "Scale", 100.0 );
			// Set the lateral axis to X
			oSettings.setStringValue( "LatAxis", "X" );
			// Set the vertical axis to Y
			oSettings.setStringValue( "VertAxis", "Y" );
			// Set the depth axis to Z
			oSettings.setStringValue( "DepthAxis", "Z" );
			// Do not invert the lateral axis
			oSettings.setBoolValue( "InvertLat", false );
			// Do not invert the vertical axis
			oSettings.setBoolValue( "InvertVert", false );
			// Do not invert the depth axis
			oSettings.setBoolValue( "InvertDepth", false );
			// Do not ignore the geometry of invisible nodes
			oSettings.setBoolValue( "IgnoreInvisible", true );
			// Do not weld seams between parent and child bones on legacy figures - deprecated
			oSettings.setBoolValue( "WeldSeams", false );
			// Do not remove vertices that are floating, connected to nothing - i.e. LOD
			oSettings.setBoolValue( "RemoveUnusedVerts", true );
			// Write vertex textures - UVs
			oSettings.setBoolValue( "WriteVT", true );
			// Do not write vertex normals
			oSettings.setBoolValue( "WriteVN", false );
			// Do not write object statements for each root node - i.e. figures, props
			oSettings.setBoolValue( "WriteO", false );
			
			// Write facet groups
			oSettings.setBoolValue( "WriteG", false );
			// Write facet groups according to whatever the geometry already has
			oSettings.setBoolValue( "GroupGeom", false );
			// Do not write facet groups according to the node it is associated with
			oSettings.setBoolValue( "GroupNodes", false );
			// Do not write facet groups according to surface groups
			oSettings.setBoolValue( "GroupSurfaces", false );
			// Do not write one facet group
			oSettings.setBoolValue( "GroupSingle", false );
			
			// Write surface groups
			oSettings.setBoolValue( "WriteUsemtl", true );
			
			// Do not write a material library
			oSettings.setBoolValue( "WriteMtllib", true );
			
			oSettings.setBoolValue( "OriginalMaps", true );
			// Do not collect texture maps
			oSettings.setBoolValue( "CollectMaps", false );
			// Do not convert texture maps
			oSettings.setBoolValue( "ConvertMaps", false );
			
			// If the version is 4.5.0.114 or newer
			if( App.version64 >= 0x0004000500000072 ){
				// Do not limit export to selection
				oSettings.setBoolValue( "SelectedOnly", false );
				// Do not limit export to the selected roots
				oSettings.setBoolValue( "SelectedRootsOnly", false );
				// Do not limit export to the primary selected root;
				// this setting overrides SelectedRootsOnly
				oSettings.setBoolValue( "PrimaryRootOnly", false );
				// Do not export items that are parented to the selection
				oSettings.setBoolValue( "IncludeParented", false );
				// Do not triangulate n-gons
				oSettings.setBoolValue( "TriangulateNgons", false );
			}
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Do not collapse UVs Tiles
				oSettings.setBoolValue( "CollapseUVTiles", false );
				
				// Show individual settings in the dialog
				oSettings.setBoolValue( "ShowIndividualSettings", false );
			}
			
			// If the version is 4.10.0.73 or newer
			if( App.version64 >= 0x0004000a00000049 ){
				// Set floating point precision; default is 8
				oSettings.setIntValue( "FloatPrecision", 6 );
			}
			
			// Define whether or not to show the options after prompting for a file
			oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/" + sName+ ".obj";
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_obj_silent ----
	
	/*********************************************************************/
	// Array<String> : ...
	// TODO: Only export base Morphs 
	function getMinimalMorphRules()
	{
		var sResult; 

		for( sMorphLabel in s_oMorphs ){
			var sMorphPath = s_oMorphs[sMorphLabel]['sMorphPath']
			var sMorphName = s_oMorphs[sMorphLabel]['sMorphName']
			if( sMorphPath.indexOf( '/Head' ) > 0 ){
				if( sMorphPath.endsWith( 'Expressions' ) ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( sMorphName );
				}
				if( sMorphPath.indexOf( '/Expressions' ) < 0 ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( sMorphName );
				}
			}
		}
		
		return sResult;
	};
	
	/*********************************************************************/
	// Array<String> : ...
	// TODO: Add better customization for Presets
	function getMorphPresets( sPreset )
	{
		var sResult 

		for( sMorphLabel in s_oMorphs ){
			var sMorphPath = s_oMorphs[sMorphLabel]['sMorphPath']
			var sMorphName = s_oMorphs[sMorphLabel]['sMorphName']
			if ( sPreset == "All Body Morphs" ){
				if ( sMorphPath.indexOf( '/Arms' ) > 0
					|| sMorphPath.indexOf( '/Hip' ) > 0
					|| sMorphPath.indexOf( '/Torso' ) > 0
					|| sMorphPath.indexOf( '/Neck' ) > 0
					|| sMorphPath.indexOf( '/Legs' ) > 0
					|| sMorphPath.indexOf( '/Hands' ) > 0
					|| sMorphPath.indexOf( '/Feet' ) > 0 ){
				sResult += sMorphName + "\n1\n";
				s_aMorphExported.push(sMorphName );
				}		
			}
			else{
				if ( sMorphPath.indexOf( '/Head' ) > 0 ){
					if ( sPreset == "Face Controls" ){
						if(!( sMorphPath.indexOf( 'Expressions' ) > 0 
							|| sMorphPath.indexOf( 'Visemes' ) > 0 ) ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( sMorphName );
						}
					}
					if ( sPreset == "Expressions" ){
						if( sMorphPath.indexOf( 'Expressions' ) > 0 ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( sMorphName );
						}
					}
					if ( sPreset == "Visemes" ){
						if	( sMorphPath.indexOf( 'Visemes' ) > 0 ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( sMorphName );
						}
					}		
				}
			}
		}
		
		return sResult;
	};

	/*********************************************************************/
	
	// void : ...
	function addBanner( wDlg, sImagePath )
	{
		var imgImage = new Image( sImagePath );
		var pixImage = (new Pixmap()).fromImage( imgImage );
		
		var wLabel = new DzLabel( wDlg );
		wLabel.pixmap = pixImage;
		wDlg.addWidget( wLabel );
	};
	
	/*********************************************************************/
	// Boolean : ...
	// TODO: Replace a listbox for a more functional option, Allow user to Choose From Their Expressions
	function promptMorphRules( oNode )
	{	
		
		var wDlg = new DzBasicDialog();
		wDlg.caption = s_sToolName + ": Morph Names";
	
		var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
		
		if( oNode ){
			wDlg.caption += " - " + oNode.getLabel();
		}
		
		var oDlgWgt = wDlg.getWidget();
		oDlgWgt.objectName = sKey;
		
		//addBanner( wDlg, App.getResourcesPath() + "/images/bridges/" + s_sToolName + ".png" );
		
		var wMinimalMorphsCbx = new DzCheckBox( wDlg );
		wMinimalMorphsCbx.text = qsTr( "Include Minimal Morphs" );
		wMinimalMorphsCbx.checked = true;
		wDlg.addWidget( wMinimalMorphsCbx );
		
		var wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wMorphNamesLbl = new DzLabel( wDlg );
		wMorphNamesLbl.text = qsTr( "Morph Names: (line separated)\n[empty = OK, partial words = OK, 3+ letters required]" );
		wDlg.addWidget( wMorphNamesLbl );
		
		var wMorphNamesTEdit = new DzTextEdit( wDlg );
		wMorphNamesTEdit.text = "";
		wDlg.addWidget( wMorphNamesTEdit );
		
		wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wValidMorphNamesLbl = new DzLabel( wDlg );
		wValidMorphNamesLbl.text = qsTr( "Valid Morph Names and Presets:\n[double-click to copy above]" );
		wDlg.addWidget( wValidMorphNamesLbl );

		var aMorphList = []
		var wValidMorphNamesLBox = new DzListBox( wDlg );
		var sMorphHead;
		var sMorphPath;

		for(var s_aMorphLabel in s_oMorphs) {
			sMorphHead = s_oMorphs[s_aMorphLabel]["sMorphHead"];
			sMorphPath = s_oMorphs[s_aMorphLabel]["sMorphPath"];
			if( sMorphHead != "Hidden" ){
				var sMorphHeaders = sMorphPath.split("/") 
				aMorphList.push( 
								sMorphHeaders[sMorphHeaders.length - 2] + " " + 
								sMorphHeaders[sMorphHeaders.length - 1] + " " +
								":" + s_s3Spaces + s_aMorphLabel
								);
			}
		}

		// Organize the Visible Morphs
		aMorphList.sort()

		for( var sMorphLabel in s_oMorphs ){
			sMorphHead = s_oMorphs[sMorphLabel]["sMorphHead"];
			if( sMorphHead == "Hidden" ){
				aMorphList.push( 
								sMorphHead + 
								":" + s_s3Spaces + sMorphLabel
								);
			}
		}

		// Add a few temporary presets for ease of use.	
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Face Controls" );
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Expressions" );
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Visemes" );	
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"All Body Morphs" );

		for( var i = 0; i < aMorphList.length; i += 1 ){
			wValidMorphNamesLBox.insertItem( aMorphList[i] );
		}
		wDlg.addWidget( wValidMorphNamesLBox );
		
		function addValidMorphName(){
			var sCurText = wValidMorphNamesLBox.currentText;
			sCurText = sCurText.split( ":"+s_s3Spaces )[1];
			wMorphNamesTEdit.append( sCurText );
		};
		wValidMorphNamesLBox.doubleClicked.connect( wValidMorphNamesLBox, addValidMorphName );
		
		var sizeHint = oDlgWgt.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 300 ? 300 : sizeHint.width;
		wDlg.setFixedSize( nWidth, sizeHint.height * 2 );
		
		if( !wDlg.exec() ){
			return false;
		}
		
		if( wMinimalMorphsCbx.checked ){
			s_sMorphRules = getMinimalMorphRules();
		}
		
		createMorphRules( wMorphNamesTEdit.text.split( "\n" ) );
	
		return true;
	};

	/*********************************************************************/
	// Take List of Morph Labels and Convert to Format for FBX Exporter
	// void : ...
	// TODO: Allow Partial Names to Export Morphs, Refactor Code to Grab Morph Info Cleaner
	function createMorphRules( aMorphLabels )
	{	
		var sMorphName;
		var sMorphLabel;
		
		// To do find a better way to stop if nothing is chosen
		if ( aMorphLabels !==undefined ){
			for( var i = 0; i < aMorphLabels.length; i += 1 ){	
				sMorphLabel = aMorphLabels[i];
				
				if ( s_oMorphs[sMorphLabel] !== undefined ){

					if (s_oMorphs[sMorphLabel]["sMorphHead"] == 'Pose' ){
					sMorphName = s_oMorphs[sMorphLabel]["sMorphName"];
					}
					else{
						//Hidden Morphs do not have labels
						sMorphName = sMorphLabel;
					}
					s_aMorphExported.push( sMorphName );
				}
				else{
					s_sMorphRules += getMorphPresets( sMorphLabel );
					}
				s_sMorphRules += sMorphName + "\n1\n";
				
			}
		}
		s_sMorphRules += "Anything\n0";

		return true;
	};

	/*********************************************************************/
	// void : ...
	function writeBoneData( oBaseNode, sFilename )
	{
		var oNode;
		var vecOrigin;
		var vecEnd;
		
		var aChildren = oBaseNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		
		var aData = new Array( nChildren );
		
		for( var i = 0; i < nChildren; i += 1 ){
			oNode = aChildren[i];
			if( !oNode.inherits( "DzBone" ) ){
				continue;
			}
			
			vecOrigin = oNode.getOrigin( true );
			vecEnd = oNode.getEndPoint( true );
			
			aData[i] = [
				oNode.name,
				vecOrigin.x,
				vecOrigin.y,
				vecOrigin.z,
				vecEnd.x,
				vecEnd.y,
				vecEnd.z
				]
				.concat( getBoneTransformValues( oNode ) )
				.join( "," );
		}
		
		aData = aData.filter( Boolean );
		if( aData.length < 1 ){
			return;
		}

		writeDataFile( aData, sFilename );
	};
	
	/*********************************************************************/
	// Array<Number> : ...
	// TODO : refactor - efficiency
	function getBoneTransformValues( oNode )
	{
		var aPosRotScale = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
		
		var aAxis = [ "X", "Y", "Z" ];
		var regxWhitespace = /\s+/g;
		
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		var sLabel;
		var sName;
		
		var aProperties = getElementProperties( oNode, true, true );
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProperty = aProperties[i];
			oOwner = oProperty.getOwner();
			if( !oOwner.inherits( "DzBone" ) ){
				continue;
			}
			
			for( var j = 0; j < aAxis.length; j += 1 ){
				sAxis = aAxis[j];
				aNames = [ sAxis + "Translate", sAxis + "Rotate" ];//Skip sAxis + "Scale"
				for( var k = 0; k < aNames.length; k += 1 ){
					sName = aNames[k];
					if( oProperty.name == sName ){
						if( !oProperty.isHidden() ){
							sLabel = oProperty.getLabel().toLowerCase().replace( regxWhitespace, "" );
							sName = sName.toLowerCase().replace( regxWhitespace, "" );
							if( !sName.startsWith( sLabel ) ){
								aPosRotScale[k*3+j] = 1;
							}
						}
					}
				}
			}
		}
		
		return aPosRotScale;
	};
	
	/*********************************************************************/
	// void : ...
	function writeMemo( sFilename, sMemo )
	{
		writeDataFile( [ sMemo ], sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function applyDefaultTransforms( oBaseNode )
	{
		var oNode;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( getKigo( oNode ) == "B" ){
				oNode.setLocalPos( s_vecDef );
				oNode.setLocalRot( s_quatDef );
				oNode.setLocalScale( s_mtxDef );
			}
		}
		
		oBaseNode.setLocalPos( s_vecDef );
		oBaseNode.setLocalRot( s_quatDef );
		oBaseNode.setLocalScale( s_mtxDef );
	};
	
	/*********************************************************************/
	// void : ...
	function writePoseData( oBaseNode, sFilename, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( bIsFigure && oTopNode.name != "hip" ){
				continue;
			}
			
			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes < 1 ){
			return;
		}
		
		var oNode;
		var sKigo;
		var vecPos;
		var quatRot;
		var mtxScale;
		var sLine;
		
		var aData = new Array( nNodes );
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sKigo = getKigo( oNode );
			vecPos = oNode.getLocalPos();
			quatRot = oNode.getLocalRot();
			mtxScale = oNode.getLocalScale();
			
			s_aPoseData.push( [ oNode.name, sKigo, vecPos, quatRot, mtxScale ] );
			
			aData[i] = [
				oNode.getLabel(),
				oNode.name,
				sKigo,
				vecPos.x,
				vecPos.y,
				vecPos.z,
				oNode.getXRotControl().getLocalValue(),
				oNode.getYRotControl().getLocalValue(),
				oNode.getZRotControl().getLocalValue(),
				mtxScale.m11,
				mtxScale.m22,
				mtxScale.m33
				].join( "," );
		}
		
		writeDataFile( aData, sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function restorePose( oBaseNode )
	{
		var oTopNode;
		var aNodes;
		var oNode;
		var aPose;
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( oTopNode.name != "hip" ){
				continue;
			}
			
			aNodes = oTopNode.getNodeChildren( true );
			aNodes.push( oTopNode );
			aNodes.unshift( oBaseNode );
			for( var j = 0; j < aNodes.length; j += 1 ){
				oNode = aNodes[j];
				if( getMeshType( oNode ) != s_oMeshTypes.Bone && j > 0 ){
					continue;
				}
				
				for( var k = 0; k < s_aPoseData.length; k += 1 ){
					aPose = s_aPoseData[k];
					if( aPose[0] == oNode.name ){
						oNode.setLocalPos( aPose[2] );
						oNode.setLocalRot( aPose[3] );
						oNode.setLocalScale( aPose[4] );
						break;
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function setLock( oBaseNode, bLock, bIsFigure )
	{
		var aNodes = oBaseNode.getNodeChildren( true );
		if( !bIsFigure ){
			aNodes.push( oBaseNode );
		}
		
		var aAxis = [ "X", "Y", "Z" ];
		
		var oNode;
		var aProperties;
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getKigo( oNode ) == 'B' ){
				continue;
			}
			
			aProperties = getElementProperties( oNode, true, true );
			for( var j = 0; j < aProperties.length; j += 1 ){
				oProperty = aProperties[ j ];
				oOwner = oProperty.getOwner();
				if( !oOwner.inherits( "DzBone" ) ){
					continue;
				}
				
				for( var k = 0; k < aAxis.length; k += 1 ){
					sAxis = aAxis[k];
					aNames = [ sAxis + "Translate", sAxis + "Rotate", sAxis + "Scale" ];
					for( var m = 0; m < aNames.length; m += 1 ){
						if( oProperty.name == aNames[m] ){
							oProperty.lock( bLock );
						}
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : rename
	function getKigo( oNode )
	{
		if( oNode.inherits( "DzBone" ) ){
			return "B";
		}
		
		if( oNode.inherits( "DzLight" ) ){
			return "L";
		}
		
		if( oNode.inherits( "DzCamera" ) ){
			return "C";
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return "E";
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return "E";
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return "E";
		}
		
		return "M";
	};
	
	/*********************************************************************/
	// void : ...
	// Morph names that are too long will cause an error in Blender 2.79.
	// Note: destructive - modifies the scene contents
	function truncateSkeletonNames( oBaseNode )
	{
		var oNode;
		var sName;
		var sTmp;
		
		var nCount = 0;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			sName = oNode.name;
			if( sName.length >= s_nMaxName ){
				sTmp = sName.substring( 0, s_nMaxName-2 );
				nCount = nCount % 36;
				sTmp = sTmp + "_" + s_sAlf.substr( nCount, 1 );
				oNode.name = sTmp;
				s_nLenName = s_nMaxName;
				nCount = nCount + 1;
			} else {
				if( sName.length > s_nLenName ){
					s_nLenName = sName.length;
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// Delete previous export
	// TODO : refactor - efficiency
	function prepareForExport( nType )
	{
		var oDir = new DzDir( "" );
		var sPath = oDir.homePath() + "/";
		
		s_sRootPath = sPath;
		
		var aFiles;
		var sDelPath;
		var oDelDir = new DzDir( "" );
		
		var aSubs = [ "Documents", "DTB", s_sEnv, s_sFig ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath = s_sRootPath + aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
			
			if( i < 2 ){
				s_sRootPath = sPath;
			} else {
				if( (i == 3 && nType == s_oExportTypes.EnvProp)
				|| (i == 2 && nType == s_oExportTypes.Figure) ){
					continue;
				}
				
				oDir.setPath( sPath );
				
				aFiles = oDir.getFilesFromDir( [], true );
				for( var j = 0; j < aFiles.length; j += 1 ){
					oDir.remove( aFiles[j] );
				}
				
				for( var j = 0; j < 100; j += 1 ){
					sDelPath = sPath + "/" + aSubs[i] + j;
					oDelDir.setPath( sDelPath );
					if( oDelDir.exists() ){
						oDir.rmdir( sDelPath );
					} else {
						break;
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function makeEndDir( nIdx, sName )
	{
		var oDir = new DzDir( "" );
		
		var sPath = s_sRootPath;
		
		var aSubs = [ sName, sName + nIdx ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath += aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	// Decide subdivison level Dialog.
	function promptMeshResolution( oNode )
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = s_sToolName + ": SubD Level";
		
		var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
		
		if( oNode ){
			wDlg.caption += " - " + oNode.getLabel();
		}
		
		var oDlgWgt = wDlg.getWidget();
		oDlgWgt.objectName = sKey;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		for( var i = 0; i < 3; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = "SubDivision Level " + i;
		}
		wOptBG.selected = 0;
		
		wDlg.addWidget( wOptBG );
		
		if( !wDlg.exec() ){
			return -1;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// void : ...
	// No eyelashes on .OBJ
	function setEyelashVisibility( oBaseNode, bOnOff )
	{
		var oNode;
		
		var aHide = [ "Eyelashes", "Eye_1", "Eye_2", "_Shell" ];
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( oNode.getNodeParent() == oBaseNode ){
				for( var j = 0; j < aHide.length; j += 1 ){ 
					if( oNode.name.indexOf( aHide[j] ) > 0 ){
						oNode.setVisible( bOnOff );
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - use oNode.assetUri instead of oNode.name
	function buildRootLists()
	{
		var oNode;
		var aChildren;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( !oNode.isVisible() ){
				if( oNode.isRootNode() ){ 
					oNode.setVisible( true );
					aChildren = oNode.getNodeChildren( true );
					for( var j = 0; j < aChildren.length; j += 1 ){
						aChildren[j].setVisible( true );
					}
				}
				
				continue;
			}
			
			if( oNode.isRootNode() && oNode.isVisible() ){
				if( 
				(oNode.name.startsWith( "Genesis8Female" )
				|| oNode.name.startsWith( "Genesis8Male" )
				|| oNode.name.startsWith( "Genesis8_1Male" )
				|| oNode.name.startsWith( "Genesis8_1Female" )
				|| oNode.name.startsWith( "Genesis3Male" )
				|| oNode.name.startsWith( "Genesis3Female" ))
					&& oNode.name.indexOf( "Eyelash" ) < 0
					&& oNode.name.indexOf( "Tear" ) < 0
				){
					s_aFigures.push( oNode );
				} else {
					s_aEnvProp.push( oNode );
				}
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function promptExportType()
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = "Select Export Type";
		
		var wLyt = new DzVBoxLayout( wDlg );
		wLyt.autoAdd = true;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		var aOptions = [ "Environment/Props", "Genesis8/3", "Both" ];
		for( var i = 0; i < aOptions.length; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = aOptions[i];
		}
		wOptBG.selected = s_oExportTypes.Figure;
		
		wDlg.addWidget( wOptBG );
		
		var oWidget = wDlg.getWidget();
		var sizeHint = oWidget.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 200 ? 200 : sizeHint.width;
		wDlg.setFixedSize( nWidth, nHeight );
		
		if( !wDlg.exec() ){
			return s_oExportTypes.None;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// Boolean : ...
	function isGenital( oNode )
	{
		var aKeys = [ "genital", "malegen_" ];
		if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
			return false;
		}
		
		var sName = oNode.name.toLowerCase();
		for( var i = 0; i < aKeys.length; i += 1 ){
			if( sName.length == 2 && sName == aKeys[i]
			|| sName.length > 2 && sName.indexOf( aKeys[i] ) >= 0 ){
				if( oNode.findNodeChild( "hip", false ) ){
					return true;
				}
			}
		}
		
		return false;
	};
	
	/*********************************************************************/
	// void : ...
	// Mesh consisting of only edges and points cannot be FBX transferred.
	// Even if it is invisible, it will be transferred, so there is no choice but to delete it.
	// Note: destructive - modifies the scene contents
	function removeIncompatibleNodes( oBaseNode )
	{
		var oNode;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		var aDelNodes = new Array( aNodes.length );
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( oNode.isRootNode() ){
				continue;
			}
			
			if( getMeshType( oNode ) == s_oMeshTypes.NoFacets ){
				aDelNodes[i] = oNode;
			}
		}
		
		aDelNodes = aDelNodes.filter( Boolean );
		
		for( var i = 0; i < aDelNodes.length; i += 1 ){
			oNode = aDelNodes[i];
			oBaseNode.removeNodeChild( oNode, true );
			oNode.setVisible( false );
			if( oNode.getLabel().endsWith( "dForce" ) ){
				Scene.removeNode( oNode );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function getMeshType( oNode )
	{
		if( !oNode ){
			return s_oMeshTypes.Other; //0
		}
		
		if( oNode.inherits( "DzBone" ) ){
			return s_oMeshTypes.Bone; //-1
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return s_oMeshTypes.Empty; //-3
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return s_oMeshTypes.Other; //0
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return s_oMeshTypes.Other; //0
		}
		
		var nFacets = oMesh.getNumFacets();
		if( nFacets < 1 && oMesh.name.toLowerCase().indexOf( "eyebrow" ) < 0 ){
			return s_oMeshTypes.NoFacets; //-2
		}
		
		if( nFacets > 14000 ){
			return s_oMeshTypes.Figure; //3
		}
		
		if( oNode.isRootNode() ){
			return s_oMeshTypes.Other; //0
		}
		
		return s_oMeshTypes.Mesh; //1
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : return success, error code, and/or message
	function writeDataFile( aData, sFilename )
	{
		var oFile = new DzFile( sFilename );
		if( !oFile.open( DzFile.WriteOnly ) ){
			print( String( "Unable to open \"%1\" for writing." ).arg( sFilename ) );
			
			return;
		}
		
		for( var i = 0; i < aData.length; i += 1 ){
			oFile.writeLine( aData[i] );
		}
		
		oFile.close();
	};
	
	/*********************************************************************/
	// void : ...
	// The mesh attached to the bone moves directly under the figure
	// Note: destructive - modifies the scene contents
	function flattenObjectHierarchy( oBaseNode )
	{
		var oChildLvl1;
		var vecChildLvl1Pos;
		var quatChildLvl1Rot;
		
		var aChildrenLvl2;
		var oChildLvl2;
		var vecChildLvl2Pos;
		var quatChildLvl2Rot;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			if( getMeshType( oChildLvl1 ) != s_oMeshTypes.Empty ){
				continue;
			}
			
			vecChildLvl1Pos = oChildLvl1.getLocalPos();
			quatChildLvl1Rot = oChildLvl1.getLocalRot();
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( true );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				vecChildLvl2Pos = oChildLvl2.getLocalPos();
				quatChildLvl2Rot = oChildLvl2.getLocalRot();
				
				vecChildLvl2Pos.x += vecChildLvl1Pos.x;
				vecChildLvl2Pos.y += vecChildLvl1Pos.y;
				vecChildLvl2Pos.z += vecChildLvl1Pos.z;
				
				quatChildLvl2Rot.x += quatChildLvl1Rot.x;
				quatChildLvl2Rot.y += quatChildLvl1Rot.y;
				quatChildLvl2Rot.z += quatChildLvl1Rot.z;
				
				oChildLvl2.setLocalPos( vecChildLvl2Pos );
				oChildLvl2.setLocalRot( quatChildLvl2Rot );
				
				oBaseNode.addNodeChild( oChildLvl2 );
			}
		}
	};
	
	/*********************************************************************/
	// Array<String> : ...
	function getParentingData( oParentNode, oBaseNode )
	{
		var aData = [];
		
		var oNode;
		var sName;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		aNodes.push( oBaseNode );
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
				continue;
			}
			
			sName = oNode.name;
			for( var j = 1; j <= 10; j += 1 ){
				if( !oNode.getLabel().endsWith( " (" + j + ")" ) ){
					continue;
				}
				
				sName += "_dup_" + j;
			}
			
			aData.push( oParentNode.name + "," + sName );
		}
		
		return aData;
	};
	
	/*********************************************************************/
	// void : ...
	function writeParentingData( oBaseNode, sFilename )
	{
		var aData = [];
		
		var oChildLvl1;
		
		var aChildrenLvl2;
		var oChildLvl2;
		
		var aChildrenLvl3;
		var oChildLvl3;
		
		var nMeshType;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( false );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				nMeshType = getMeshType( oChildLvl2 );
				//It's mesh(child)
				if( nMeshType > s_oMeshTypes.Other ){
					//Parent is bone
					if( getMeshType( oChildLvl1 ) == s_oMeshTypes.Bone ){
						aData = aData.concat( getParentingData( oChildLvl1, oChildLvl2 ) );
					}
				//It's Empty(Child)
				} else if( nMeshType == s_oMeshTypes.Empty ){
					aChildrenLvl3 = oChildLvl2.getNodeChildren( false );
					for( var k = 0; k < aChildrenLvl3.length; k += 1 ){
						oChildLvl3 = aChildrenLvl3[k];
						//Grandchild is mesh.
						//child's parent, parent child (sibling?) is bone
						if( getMeshType( oChildLvl3 ) > s_oMeshTypes.Other ){
							if( getMeshType( oChildLvl1.getNodeParent() ) == s_oMeshTypes.Bone ){
								aData = aData.concat( getParentingData( oChildLvl1, oChildLvl3 ) );
							}
						}
					}
				}
			}
		}
		
		if( aData.length > 0 ){
			writeDataFile( aData, sFilename );
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : remove - not used
	// Note: destructive - modifies the scene contents
	function lockNodeTransforms( oNode )
	{
		oNode.getToolXRotControl().lock( true );
		oNode.getToolYRotControl().lock( true );
		oNode.getToolZRotControl().lock( true );
		oNode.getOrientXControl().lock( true );
		oNode.getOrientYControl().lock( true );
		oNode.getOrientZControl().lock( true );
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : remove - not used
	function getTransformAsCSV( oNode, vecPos, mtxScale )
	{
		var sResult = vecPos.x + "," + vecPos.y + "," + vecPos.z + ",";
		
		sResult += oNode.getXRotControl().getLocalValue() + ",";
		sResult += oNode.getYRotControl().getLocalValue() + ",";
		sResult += oNode.getZRotControl().getLocalValue() + ",";
		
		sResult += mtxScale.m11 + "," + mtxScale.m22 + "," + mtxScale.m33;
		
		return sResult;
	};
	
	/*********************************************************************/
	// void : ...
	// Apply subdivision levels to figures and genitals.
	function setSubDivLevelAll( oBaseNode, nLevel )
	{
		var bIsBody;
		var bIsGen;
		var nLev;
		var oNode;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			bIsBody = oNode == oBaseNode;
			bIsGen = !bIsBody && oNode.getNodeParent() == oBaseNode && isGenital( oNode );
			nLev = 0;
			if( bIsBody || bIsGen ){
				nLev = nLevel;
			}
			
			setSubDivLevel( oNode, nLev );
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setSubDivLevel( oNode, nLevel )
	{
		var aProps = [ "lodlevel", "SubDIALevel" ];
		var oObject = oNode.getObject();
		if( !oObject ){
			return;
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return;
		}
		
		var oProp;
		for( var i = 0; i < aProps.length; i += 1 ){
			oProp = oShape.findProperty( aProps[i] );
			if( oProp ){
				if( oProp.isLocked() ){
					oProp.lock( false );
				}
				
				if( i == 0 && nLevel == 0 ){
					oProp.setValue( "Basic" );
				} else {
					oProp.setValue( nLevel );
				}
				
				if( nLevel > 0 ){
					oProp.lock( true );
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setHideRoot( bIsFigure, bYesNo )
	{
		if( bIsFigure ){
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				setVisible( s_aFigures[i], bYesNo );
			}
		} else {
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				setVisible( s_aEnvProp[i], bYesNo );
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setVisible( oBaseNode, bYesNo )
	{
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			aChildren[i].setVisible( bYesNo );
		}
		
		oBaseNode.setVisible( bYesNo );
	};

	/*********************************************************************/
	// Number : Get the sign of the input number
	function getSign( nInput )
	{
		if( nInput >= 0 ){
			return 1;
		} else{
			return -1;
		}
	}

	/*********************************************************************/
	// Number : Get the direction of the bone's look at axis. 1 or -1
	function getLookAtDirection( oNode )
	{
		var vecLookAtAxis = oNode.getEndPoint().subtract( oNode.getOrigin() );
		
		var nSign = 1;
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nSign = getSign( vecLookAtAxis.x );
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nSign = getSign( vecLookAtAxis.y );
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nSign = getSign( vecLookAtAxis.z );
		}
		
		return nSign;
	};

	/*********************************************************************/
	// DzVec3 : Get the second axis of the node
	function getNodeSecondAxis( oNode )
	{
		var vecSecondAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().secondAxis == 0 ){
			vecSecondAxis.x = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 1 ){
			vecSecondAxis.y = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 2 ){
			vecSecondAxis.z = nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecSecondAxis = quatOrientation.multVec( vecSecondAxis );
		
		return vecSecondAxis;
	};

	/*********************************************************************/
	// DzVec3 : Get the primary axis of the node
	function getNodePrimaryAxis( oNode, nBoneLength )
	{
		var vecFirstAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().firstAxis == 0 ){
			vecFirstAxis.x = nBoneLength * nSign;
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			vecFirstAxis.y = nBoneLength * nSign;
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			vecFirstAxis.z = nBoneLength * nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecFirstAxis = quatOrientation.multVec( vecFirstAxis );
		
		return vecFirstAxis;
	};

	/*********************************************************************/
	// Float : Get length of the bone
	function getBoneNodeLength( oNode )
	{
		var vecAlongBone = oNode.getEndPoint().subtract( oNode.getOrigin() );
		return vecAlongBone.length();
	}

	/*********************************************************************/
	// Void : Write bone's limits along with rotation orders
	function writeFigureBoneData( oBaseNode, sFilename )
	{
		if( !oBaseNode.inherits("DzFigure") ){
			return;
		}
		
		var oSkeleton = oBaseNode.getSkeleton();
		var aNodes = oSkeleton.getAllBones();
		var numFollowers = oSkeleton.getNumFollowSkeletons();
		var oFollowSkeleton;
		var aFollowNodes;
		var oFollowNode;
		var bIsNewNode;
		
		// Collect followers' bones that does not exist in the main skeleton
		for( var i = 0; i < numFollowers; i += 1 ){
			oFollowSkeleton = oSkeleton.getFollowSkeleton( i );
			aFollowNodes = oFollowSkeleton.getAllBones();
			for( var j = 0; j < aFollowNodes.length; j += 1 ){
				oFollowNode = aFollowNodes[j];
				bIsNewNode = false;
				for( var k = 0; k < aNodes.length; k += 1 ){
					if( oFollowNode.name == aNodes[k].name ){
						bIsNewNode = true;
						break;
					}
				}

				if( bIsNewNode == false ){
					aNodes = aNodes.concat( aFollowNodes[j] );
				}
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes == 0 ){
			return;
		}
		
		var oNode;
		var sRotOrder;
		var nXRotMin;
		var nXRotMax;
		var nYRotMin;
		var nYRotMax;
		var nZRotMin;
		var nZRotMax;
		
		var aLimitsData = new Array( nNodes );
		var aHeadTailData = new Array( nNodes );
		var aSkeletonData = new Array( 1 );
		
		// To account for the scale on the skeleton due to morphs
		var nSkeletonScale = oBaseNode.getScaleControl().getValue();
		aSkeletonData[0] = ["skeletonScale", nSkeletonScale].join(",");
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			
			sRotOrder = oNode.getRotationOrder().toString();
			nXRotMin = oNode.getXRotControl().getMin();
			nXRotMax = oNode.getXRotControl().getMax();
			nYRotMin = oNode.getYRotControl().getMin();
			nYRotMax = oNode.getYRotControl().getMax();
			nZRotMin = oNode.getZRotControl().getMin();
			nZRotMax = oNode.getZRotControl().getMax();
			aLimitsData[i] = [
				oNode.getName(),
				sRotOrder,
				nXRotMin, nXRotMax,
				nYRotMin, nYRotMax,
				nZRotMin, nZRotMax
				].join(",");
			
			nBoneLength = getBoneNodeLength( oNode );
			vecPrimaryAxis = getNodePrimaryAxis( oNode, nBoneLength );
			vecHead = oNode.getOrigin( false );
			vecTail = vecHead.add( vecPrimaryAxis );
			vecSecondAxis = getNodeSecondAxis( oNode );
			aHeadTailData[i] = [
				oNode.getName(),
				vecHead.x * nSkeletonScale,
				vecHead.y * nSkeletonScale,
				vecHead.z * nSkeletonScale,
				vecTail.x * nSkeletonScale,
				vecTail.y * nSkeletonScale,
				vecTail.z * nSkeletonScale,
				vecSecondAxis.x,
				vecSecondAxis.y,
				vecSecondAxis.z
				].join(",");
		}
		
		writeDataFile( aLimitsData, sFilename + "_boneLimits.csv" );
		writeDataFile( aHeadTailData, sFilename + "_boneHeadTail.csv" );
		writeDataFile( aSkeletonData, sFilename + "_skeletonData.csv" );
	};
	/*********************************************************************/	
	// void : ...
	// Note: Configure DTU File
	// TO DO: Grab Subdivision info and Morphs Exporting
	function writeConfiguration( oNode, sFilename )
	{
		var sDtufilename = sFilename + ".dtu";
		var oDtufile = new DzFile( sDtufilename );
		var oDtuJson = {};
		var aChildren = oNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		
		oDtuJson["Asset Name"] = oNode.getLabel();
		oDtuJson["Materials"] = [];
		aFigureMats = writeMaterials( oNode );
		oDtuJson["Materials"].push( aFigureMats );
		oDtuJson['Morphs'] = s_aMorphExported;
		if (nChildren > 0){
			for ( var i = 0; i < nChildren; i++ ){
				var oChild = aChildren[ i ]; 
				aChildMats = writeMaterials( oChild );
				if ( aChildMats != false ){
					oDtuJson["Materials"].push( aChildMats );
				}		
			}
		};
		
		function combineMaterials( key, value ){
			var aNewMaterials = [];
			if( key == "Materials" ){
				for (var i=0; i < value.length; i++ ){
					var aNodeMats = value[i];
					for (var k=0; k < aNodeMats.length; k++ ){
						var aMat = aNodeMats[k];
						aNewMaterials.push( aMat );
					}
				}
				return aNewMaterials;
			}
			else{
				return value;
			}
		};

		oDtufile.open( DzFile.WriteOnly );
		oDtufile.write( JSON.stringify( oDtuJson, combineMaterials, 4 ) );
		oDtufile.close();
	};

	/*********************************************************************/	
	// Array : ...
	// Note: Cycle through all the Materials on a Node and return an array
	function writeMaterials( oNode )
	{	
		var oObj = oNode.getObject();
		if( oObj != null ){
			var oShape = oObj.getCurrentShape();
			var nMat = oShape.getNumMaterials();
			var aMaterials = [];
			if( oShape ){
				for( var k=0; k < nMat; k++ ){
					var oAssetInfo = {};
					var aProperties = [];
					var oMat = oShape.getMaterial( k );
					if(oMat){	
						oAssetInfo["Asset Name"] = oNode.getLabel();
						oAssetInfo["Material Name"] = oMat.getName();
						oAssetInfo["Material Type"] = oMat.getMaterialName();
						
						var oPresentation = oNode.getPresentation();
						if( oPresentation != undefined ){
							var sPresentationType = oPresentation.type
							oAssetInfo["Value"]  = sPresentationType;
						}
						else{
							oAssetInfo["Value"]  = "Unknown";
						}
						for( var i = 0; i < oMat.getNumProperties(); i++){	
							var oProperty =oMat.getProperty( i );
							var bImageProperty = oProperty.inherits( "DzImageProperty" );
							var bColorProperty = oProperty.inherits( "DzColorProperty" );
							var bNumericProperty = oProperty.inherits( "DzNumericProperty" );

							if( bImageProperty ){
								var sName = oProperty.getName();
								var sTextureName ="";
								if(oProperty.getValue()){
									sTextureName = oProperty.getValue().getFilename();	
								}
								aProperties.push(
									{
									"Name" : sName,
									"Value" : oMat.getDiffuseColor().name,
									"Data Type" : "Texture",
									"Texture" : sTextureName
									}
								);
							}
							
							if( bColorProperty ){
								var sName = oProperty.getName();
								var sTextureName ="";
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								aProperties.push(
									{
									"Name" : sName,
									"Value" : oProperty.getColorValue().name,
									"Data Type" : "Color",
									"Texture" : sTextureName
									}
								)
							}

							if( bNumericProperty ){
								// To deal with Color Property being the Choice we want.
								if( !bColorProperty){
									var sName = oProperty.getName();
									var sTextureName ="";
									if ( oProperty.getMapValue() ){
										sTextureName = oProperty.getMapValue().getFilename();
									}
									aProperties.push(
										{
										"Name" : sName,
										"Value" : oProperty.getValue(),
										"Data Type" : "Double",
										"Texture" : sTextureName
										}
									)
								}
							}
						}
		
					oAssetInfo["Properties"] = aProperties;
					aMaterials.push( oAssetInfo );
					}
				}						
			}
			return aMaterials
		}
		else{
			return false
		}
	};

	/*********************************************************************/
	// void : ...
	function main()
	{
		var bDebugFBX = false;
		
		buildRootLists();
		
		if( s_aFigures.length > 2 ){
			if( MessageBox.warning(
				qsTr( "Transferring 3 or more figures with clothing or hair may freeze and stop." ),
				s_sToolName, qsTr( "&OK" ), qsTr( "&Cancel" ) ) == 1 ){
				return;
			}
		}
		
		if( s_aFigures.length == 0 && s_aEnvProp.length == 0 ){
			return;
		} else if( s_aFigures.length > 0 && s_aEnvProp.length > 0 ){
			s_nExportType = s_oExportTypes.Both;
		} else if( s_aEnvProp.length == 0 ){
			s_nExportType = s_oExportTypes.Figure;
		} else if( s_aFigures.length == 0 ){
			s_nExportType = s_oExportTypes.EnvProp;
		}
		
		if( s_nExportType == s_oExportTypes.Both ){
			s_nExportType = promptExportType();
		}
		
		if( s_nExportType == s_oExportTypes.None ){
			return;
		}
		
		prepareForExport( s_nExportType );
		
		var sFileBasename;
		
		if( s_nExportType == s_oExportTypes.Both
		|| s_nExportType == s_oExportTypes.Figure ){
			setHideRoot( false, false );
			
			var oFigure;
			var nLevel;
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				oFigure = s_aFigures[i];
				
				for( var j = 0; j < s_aFigures.length; j += 1 ){
					setVisible( s_aFigures[j], i == j );
				}
				
				nLevel = promptMeshResolution( oFigure );
				if( nLevel < 0 ){
					continue;
				}
				
				sFileBasename = String( "%1%2/%2%3/%2" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				
				setLock( oFigure, true, true );
				makeEndDir( i, s_sFig );
				buildMorphList( oFigure );
				writeFigureBoneData( oFigure, sFileBasename );
				writePoseData( oFigure, sFileBasename + ".csv", true );
				writeParentingData( oFigure, sFileBasename + ".dat" );
				setSubDivLevelAll( oFigure, nLevel );
	
				if( !promptMorphRules( oFigure) ){
					continue;
				}
				writeConfiguration( oFigure, sFileBasename );
				setEyelashVisibility( oFigure, false );
				exportOBJ( oFigure, s_sFig, i );
				setEyelashVisibility( oFigure, true );
				removeIncompatibleNodes( oFigure );
				exportFBX( oFigure, s_sFig, i , bDebugFBX );
				setLock( oFigure, false, true );
				restorePose( oFigure );
			}
		}
		
		if( s_nExportType != s_oExportTypes.Figure ){
			setHideRoot( true, false );
			
			var oNode;
			var bIsBone;
			var sEnvPath;
			var sPoseFilename;
			var sBoneFilename;
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				oNode = s_aEnvProp[i];
				
				for( var j = 0; j < s_aEnvProp.length; j += 1 ){
					setVisible( s_aEnvProp[j], i == j );
				}
				
				bIsBone = oNode.getSkeleton() != null;
				if( bIsBone ){
					flattenObjectHierarchy( oNode );
				}
				
				setLock( oNode, true, false );
				
				setSubDivLevelAll( oNode, 0 );
				
				sEnvPath = String( "%1%2/%2%3/" ).arg( s_sRootPath ).arg( s_sEnv ).arg( i );
				makeEndDir( i, s_sEnv );
				
				if( oNode.name.startsWith( "Genesis" ) ){
					applyDefaultTransforms( oNode );
				}
				
				exportFBX( oNode, s_sEnv, i, bDebugFBX );
				
				sFileBasename = sEnvPath + s_sEnv;
				sPoseFilename = sFileBasename + ".csv";
				sBoneFilename = sFileBasename + ".bon";

				writeConfiguration( oNode, sFileBasename );
				if( bIsBone ){
					writeBoneData( oNode, sBoneFilename );
				} else {
					writePoseData( oNode, sPoseFilename, false );
					writeMemo( sEnvPath + "nobone.txt", "not skeleton" );
				}
				
				setLock( oNode, false, false );
			}
		}
		
		setHideRoot( true, true );
		setHideRoot( false, true );
	};
	
	/*********************************************************************/
	main();
	
})();