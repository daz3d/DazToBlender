// DAZ Studio version 4.12.0.86 filetype DAZ Script

(function(){
	
	var s_oFileInfo = new DzFileInfo( getScriptFileName() );
	var s_sToolName = s_oFileInfo.baseName();
	s_oFileInfo.deleteLater();
	
	var s_aFigures = [];
	var s_aEnvProp = [];
	
	var s_sFig = "FIG";
	var s_sEnv = "ENV";
	
	var s_oMeshTypes = {
		"Figure" :3,
		"Mesh" : 1,
		"Other" : 0,
		"Bone" : -1,
		"NoFacets" : -2,
		"Empty" : -3
	};
	
	var s_oExportTypes = {
		"Both" : 2,
		"Figure" : 1,
		"EnvProp" : 0,
		"None" : -1
	};
	var s_nExportType = s_oExportTypes.None;
	
	var s_sMorphRules = "";
	
	var s_sRootPath = "";
	
	var s_aMorphs = {};
	var s_aSearch = [];
	var s_nLenName = 0;
	var s_nMaxName = 19;
	var s_nMaxAll = 63;
	var s_s3Spaces = "   ";
	var s_sAlf = "1234567890abcdefghijklmnopqrstuvwxyz";
	
	var s_vecDef = new DzVec3( 0, 0, 0 );
	var s_quatDef = new DzQuat( 0, 0, 0, 1, true );
	var s_mtxDef = new DzMatrix3( s_quatDef );
	
	var s_aPoseData = [];
	
	/*********************************************************************/
	// void : ...
	// Note: destructive - modifies the scene contents
	function buildMorphList( oNode )
	{
		if( oNode.inherits( "DzFigure" ) ){
            oNode = oNode.getSkeleton();
			var aProperties = getElementProperties( oNode, true, true );
        }
        
		else{
			var aProperties = getElementProperties( oNode, true, true );
		}
		var nAlfIdx = 0;
		var aTops = [ "Morphs", "Hidden", "Pose" ];
		
		var oProp;
		var oOwner;
		var oTop;
		var sPath;
		var sHead;
		var sLabel;
		var sTmp;
		
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProp = aProperties[ i ];
			oOwner = oProp.getOwner();
			sPath = oProp.getPath();
			sHead = "";

			for( var j = 0; j < aTops.length; j += 1 ){
				oTop = aTops[j];
				if( sPath.indexOf( "/" + oTop ) == 0 ){
					sHead = "<" + oTop + ">";
					break;
				}
			}
			
			if( sHead.isEmpty() ){
				continue;
			}
			
			
			sLabel = oProp.getLabel();
			if( (sLabel.length + 2 + s_nMaxName) > s_nMaxAll ){
				sLabel = sLabel.slice( 0, s_nMaxAll - s_nMaxName - 2 - 2 );
				sLabel = sLabel + "_" + s_sAlf.substr( nAlfIdx, 1 );
				oOwner.name = sLabel;
				nAlfIdx += 1;
				nAlfIdx = nAlfIdx % 36;
			}
			
			sName = oProp.getName()
			// To do sort all the data for Morphs to create more cleaner UI
			s_aMorphs[sLabel] = {'sMorphHead': sHead, "sMorphName" : sName, "sMorphPath" : sPath};

		}
	};
	
	
// --- START node_properties ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/properties/node_properties/start
 	
 	// - Extraccted functions
 	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting a list of the properties in a group
	function getGroupProperties( oGroup, bTraverse, bRecurse )
	{
		// Declare an array to hold properties
		var aProperties = [];
		
		// If a group is not passed in
		if( !oGroup ){
			// We are done, return an empty array
			return aProperties;
		}
		
		// Get the number of proeprties in the group
		var nProperties = oGroup.getNumProperties();
		// Pre-size the properties array
		aProperties = new Array( nProperties );
		// Iterate over the properties, setting each element in the array
		for( var i = 0; i < nProperties; i += 1 ){
			// Assign the property to the position in the array
			aProperties[ i ] = oGroup.getProperty( i );
		}
		
		// If we are recursing
		if( bRecurse ){
			// Concatenate the properties array from child groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getFirstChild(), true, bRecurse ) );
		}
		
		// If we are traversing
		if( bTraverse ){
			// Concatenate the properties array from sibling groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getNextSibling(), bTraverse, bRecurse ) );
		}
 		
		// Return the array of properties
		return aProperties;
	};
	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting the list properties for an element
	function getElementProperties( oElement, bTraverse, bRecurse )
	{
		// Get the property group tree for the element
		var oPropertyGroupTree = oElement.getPropertyGroups();
		
		// If the application version is 4.9.4.101 or newer and we want all properties
		if( App.version64 >= 0x0004000900040065 && bTraverse && bRecurse ){
			// Return the properties for the element
			return oPropertyGroupTree.getAllProperties();
		}
		
		// Get the first group in the tree
		var oPropertyGroup = oPropertyGroupTree.getFirstChild();
		// Return the properties for the element
		return getGroupProperties( oPropertyGroup, bTraverse, bRecurse );
	};
	
// --- END node_properties ----
	
	
// --- START export_fbx_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_fbx_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportFBX( oNode, sName, nIdx, bAscii )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Autodesk Filmbox (*.fbx) exporter
		var sClassName = "DzFbxExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Selected
			oSettings.setBoolValue( "doSelected", false );
			// No Hidden
			oSettings.setBoolValue( "doVisible", true );
			// Figures
			oSettings.setBoolValue( "doFigures", true );
			
			var bIsEnv = sName.startsWith( s_sEnv );
			// Props
			oSettings.setBoolValue( "doProps", bIsEnv );
			// Lights
			oSettings.setBoolValue( "doLights", bIsEnv );
			// Cameras
			oSettings.setBoolValue( "doCameras", bIsEnv );
			
			// Animations
			oSettings.setBoolValue( "doAnims", true );
			// Morphs
			oSettings.setBoolValue( "doMorphs", true );
			
			// Fps
			oSettings.setBoolValue( "doFps", true );
			
			// Morph Rules
			// Format for rules is "Match1\nAction1\nMatch2\nAction2\nMatch3\nAction3",
			// where Match# is a string to search for and Action# is one of Bake|Export|Ignore
			// The names of the morphs are in the form: node_name.parameter_name
			// The default action is to Bake
			// So "FBMHeavy\nExport\nThin\nExport" would export all morphs that have FBMHeavy and all morphs that have Thin in the name
			oSettings.setStringValue( "rules", s_sMorphRules );
			
			// Format
			// Format for format is "Year# -- Type",
			// where Year# is one of 2006|2009|2010|2011|2012|2013|2014 and
			// Type is one of Ascii|Binary
			if( bAscii ){
				oSettings.setStringValue( "format", "FBX 2014 -- Ascii" );
			} else {
				oSettings.setStringValue( "format", "FBX 2014 -- Binary" );
			}
			
			// Embed Textures
			oSettings.setBoolValue( "doEmbed", false );
			// Collect Textures To Folder
			oSettings.setBoolValue( "doCopyTextures", false );
			// Merge Diffuse and Opacity Textures
			oSettings.setBoolValue( "doDiffuseOpacity", false );
			// Merge Clothing Into Figure Skeleton
			oSettings.setBoolValue( "doMergeClothing", true );
			// Convert Clothing to Static Geometry
			oSettings.setBoolValue( "doStaticClothing", false );
			// Allow Degraded Skinning
			oSettings.setBoolValue( "degradedSkinning", false );
			// Allow Degraded Scaling
			oSettings.setBoolValue( "degradedScaling", false );
			// SubD Information
			oSettings.setBoolValue( "doSubD", false );
			// Collapse UV Tiles
			//oSettings.setBoolValue( "doCollapseUVTiles", false );
			
			oSettings.setBoolValue( "doLocks", false );
			oSettings.setBoolValue( "doLimits", false );
			oSettings.setBoolValue( "doBaseFigurePoseOnly", false );
			oSettings.setBoolValue( "doHelperScriptScripts", false );
			oSettings.setBoolValue( "doMentalRayMaterials", false );
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Define whether or not to show the options after prompting for a file;
				// prior to 4.9.3.22 this exporter ignored this option entirely,
				// running silent was implied by virtue of being run via script
				oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			}
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/";
			if( bAscii ){
				sPath += "A_" + sName + ".fbx"
			} else {
				sPath += "B_" + sName + ".fbx"
			}
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_fbx_silent ----
	
	
// --- START export_obj_silent ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_obj_silent/start
	
	// - Minor changes for this specific use case
	
	// void : ...
	function exportOBJ( oNode, sName, nIdx )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Define the class name the for Wavefront Object (*.obj) exporter
		var sClassName = "DzObjExporter";
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			// Set the scale to write the data
			oSettings.setFloatValue( "Scale", 100.0 );
			// Set the lateral axis to X
			oSettings.setStringValue( "LatAxis", "X" );
			// Set the vertical axis to Y
			oSettings.setStringValue( "VertAxis", "Y" );
			// Set the depth axis to Z
			oSettings.setStringValue( "DepthAxis", "Z" );
			// Do not invert the lateral axis
			oSettings.setBoolValue( "InvertLat", false );
			// Do not invert the vertical axis
			oSettings.setBoolValue( "InvertVert", false );
			// Do not invert the depth axis
			oSettings.setBoolValue( "InvertDepth", false );
			// Do not ignore the geometry of invisible nodes
			oSettings.setBoolValue( "IgnoreInvisible", true );
			// Do not weld seams between parent and child bones on legacy figures - deprecated
			oSettings.setBoolValue( "WeldSeams", false );
			// Do not remove vertices that are floating, connected to nothing - i.e. LOD
			oSettings.setBoolValue( "RemoveUnusedVerts", true );
			// Write vertex textures - UVs
			oSettings.setBoolValue( "WriteVT", true );
			// Do not write vertex normals
			oSettings.setBoolValue( "WriteVN", false );
			// Do not write object statements for each root node - i.e. figures, props
			oSettings.setBoolValue( "WriteO", false );
			
			// Write facet groups
			oSettings.setBoolValue( "WriteG", false );
			// Write facet groups according to whatever the geometry already has
			oSettings.setBoolValue( "GroupGeom", false );
			// Do not write facet groups according to the node it is associated with
			oSettings.setBoolValue( "GroupNodes", false );
			// Do not write facet groups according to surface groups
			oSettings.setBoolValue( "GroupSurfaces", false );
			// Do not write one facet group
			oSettings.setBoolValue( "GroupSingle", false );
			
			// Write surface groups
			oSettings.setBoolValue( "WriteUsemtl", true );
			
			// Do not write a material library
			oSettings.setBoolValue( "WriteMtllib", true );
			
			oSettings.setBoolValue( "OriginalMaps", true );
			// Do not collect texture maps
			oSettings.setBoolValue( "CollectMaps", false );
			// Do not convert texture maps
			oSettings.setBoolValue( "ConvertMaps", false );
			
			// If the version is 4.5.0.114 or newer
			if( App.version64 >= 0x0004000500000072 ){
				// Do not limit export to selection
				oSettings.setBoolValue( "SelectedOnly", false );
				// Do not limit export to the selected roots
				oSettings.setBoolValue( "SelectedRootsOnly", false );
				// Do not limit export to the primary selected root;
				// this setting overrides SelectedRootsOnly
				oSettings.setBoolValue( "PrimaryRootOnly", false );
				// Do not export items that are parented to the selection
				oSettings.setBoolValue( "IncludeParented", false );
				// Do not triangulate n-gons
				oSettings.setBoolValue( "TriangulateNgons", false );
			}
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Do not collapse UVs Tiles
				oSettings.setBoolValue( "CollapseUVTiles", false );
				
				// Show individual settings in the dialog
				oSettings.setBoolValue( "ShowIndividualSettings", false );
			}
			
			// If the version is 4.10.0.73 or newer
			if( App.version64 >= 0x0004000a00000049 ){
				// Set floating point precision; default is 8
				oSettings.setIntValue( "FloatPrecision", 6 );
			}
			
			// Define whether or not to show the options after prompting for a file
			oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			
			// If we've got a node, construct the path using the
			// exporter's last path, the node's name, and the
			// exporter's extension...
			// Otherwise, just use the exporter's last path
			var sInitialPath = ( oNode ?
				String( "%1/%2.%3" )
					.arg( oExportMgr.getExportPath() )
					.arg( oNode.name )
					.arg( oExporter.getExtension() ) :
				oExportMgr.getExportPath() );
			
			var sPath = s_sRootPath + sName + "/" + sName + nIdx + "/" + sName+ ".obj";
			
			// If the user didn't cancel and the file doesn't already
			// exist, or the user wants to overwrite it
			if( sPath && MainWindow.checkExistingFile( sPath ) ){
				// Write the file using the options specified
				oExporter.writeFile( sPath, oSettings );
			}
			
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr( "An exporter with the class name \"%1\" " +
				"could not be found." ).arg( sClassName ),
				s_sToolName, qsTr( "&OK" ) );
		}
	};
	
// --- END export_obj_silent ----
	
	/*********************************************************************/
	// Array<String> : ...
	function getMinimalMorphRules()
	{
		
		var sResult 
		for(sMorphLabel in s_aMorphs){
			if (s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Head') > 0)
			{
				sResult += s_aMorphs[sMorphLabel]['sMorphName'] + "\n1\n";
			}
		}
		
		return sResult;
	};
	
	/*********************************************************************/
	// Array<String> : ...
	function getMorphPresets(sPreset)
	{
		
		var sResult 
		for(sMorphLabel in s_aMorphs){
			if (sPreset == "All Body Morphs"){
				if (s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Arms') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Hip') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Torso') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Neck') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Legs') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Hands') > 0
					||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Feet') > 0){
				sResult += s_aMorphs[sMorphLabel]['sMorphName'] + "\n1\n";
				}		
			}
			else{
				if (s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('/Head') > 0){
					if (sPreset == "Face Controls"){
						if(!(s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('Expressions') > 0 
							||s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('Visemes') > 0 )){
							sResult += s_aMorphs[sMorphLabel]['sMorphName'] + "\n1\n";
						}
					}
					if (sPreset == "Expressions"){
						if( s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('Expressions') > 0){
							sResult += s_aMorphs[sMorphLabel]['sMorphName'] + "\n1\n";
						}
					}
					if (sPreset == "Visemes"){
						if	( s_aMorphs[sMorphLabel]['sMorphPath'].indexOf('Visemes') > 0 ){
							sResult += s_aMorphs[sMorphLabel]['sMorphName'] + "\n1\n";
						}
					}		
				}
			}
		}
		
		return sResult;
	};
	
	/*********************************************************************/
	
	// void : ...
	function addBanner( wDlg, sImagePath )
	{
		var imgImage = new Image( sImagePath );
		var pixImage = (new Pixmap()).fromImage( imgImage );
		
		var wLabel = new DzLabel( wDlg );
		wLabel.pixmap = pixImage;
		wDlg.addWidget( wLabel );
	};
	
	/*********************************************************************/
	// Boolean : ...
	function promptMorphRules( oNode)
	{	
		
		var wDlg = new DzBasicDialog();
		wDlg.caption = s_sToolName + ": Morph Names";
	
		var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
		
		if( oNode ){
			wDlg.caption += " - " + oNode.getLabel();
		}
		
		var oDlgWgt = wDlg.getWidget();
		oDlgWgt.objectName = sKey;
		
		//addBanner( wDlg, App.getResourcesPath() + "/images/bridges/" + s_sToolName + ".png" );
		
		var wMinimalMorphsCbx = new DzCheckBox( wDlg );
		wMinimalMorphsCbx.text = qsTr( "Include Minimal Morphs" );
		wMinimalMorphsCbx.checked = true;
		wDlg.addWidget( wMinimalMorphsCbx );
		
		var wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wMorphNamesLbl = new DzLabel( wDlg );
		wMorphNamesLbl.text = qsTr( "Morph Names: (line separated)\n[empty = OK, partial words = OK, 3+ letters required]" );
		wDlg.addWidget( wMorphNamesLbl );
		
		var wMorphNamesTEdit = new DzTextEdit( wDlg );
		wMorphNamesTEdit.text = "";
		wDlg.addWidget( wMorphNamesTEdit );
		
		wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wValidMorphNamesLbl = new DzLabel( wDlg );
		wValidMorphNamesLbl.text = qsTr( "Valid Morph Names and Presets:\n[double-click to copy above]" );
		wDlg.addWidget( wValidMorphNamesLbl );
		// TODO Replace a listbox for a more functional option
		var sMorphList = []
		var wValidMorphNamesLBox = new DzListBox( wDlg );
		for(var s_aMorphLabel in s_aMorphs) {
			if(s_aMorphs[s_aMorphLabel]["sMorphHead"] != "Hidden"){
				var sMorphHeaders = s_aMorphs[s_aMorphLabel]['sMorphPath'].split("/") 
				sMorphList.push(sMorphHeaders[sMorphHeaders.length -2] + " "+ 
											sMorphHeaders[sMorphHeaders.length -1] + " "+
											":" + s_s3Spaces + s_aMorphLabel);
			}
	
		}
		// Organize the Visible Morphs
		sMorphList.sort()
		for(var s_aMorphLabel in s_aMorphs){
			if(s_aMorphs[s_aMorphLabel]["sMorphHead"] == "Hidden"){
				sMorphList.push(s_aMorphs[s_aMorphLabel]["sMorphHead"] + 
								":" + s_s3Spaces + s_aMorphLabel);
			}
		}
		// Add a few temporary presets for ease of use.	
		wValidMorphNamesLBox.insertItem("Presets:" + s_s3Spaces +"Face Controls");
		wValidMorphNamesLBox.insertItem("Presets:" + s_s3Spaces +"Expressions");
		wValidMorphNamesLBox.insertItem("Presets:" + s_s3Spaces +"Visemes");	
		wValidMorphNamesLBox.insertItem("Presets:" + s_s3Spaces +"All Body Morphs");
		for( var i = 0; i < sMorphList.length; i += 1 ){
		
			wValidMorphNamesLBox.insertItem(sMorphList[i]);
		}
		wDlg.addWidget( wValidMorphNamesLBox );
		
		function addValidMorphName()
		{
			var sCurText = wValidMorphNamesLBox.currentText;
			sCurText = sCurText.split(":"+s_s3Spaces)[1];
			wMorphNamesTEdit.append( sCurText );
		};
		wValidMorphNamesLBox.doubleClicked.connect( wValidMorphNamesLBox, addValidMorphName );
		
		var sizeHint = oDlgWgt.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 300 ? 300 : sizeHint.width;
		wDlg.setFixedSize( nWidth, sizeHint.height * 2 );
		
		if( !wDlg.exec() ){
			return false;
		}
		
		if( wMinimalMorphsCbx.checked ){
			s_sMorphRules = getMinimalMorphRules();
		}
		
		createMorphRules(wMorphNamesTEdit.text.split("\n"));
	
		return true;
	};
	/*********************************************************************/
	// Take List of Morph Labels and Convert to Format for FBX Exporter
	// void : ...
	function createMorphRules(aMorphLabels)
	{	
		var sMorphName;
		var s_aMorphLabel;
		
		// To do find a better way to stop if nothing is chosen
		if (aMorphLabels !==undefined){
			
			for( var i = 0; i < aMorphLabels.length; i += 1 ){	
				
				s_aMorphLabel = aMorphLabels[i];
				if (s_aMorphs[s_aMorphLabel] !== undefined){

					if (s_aMorphs[s_aMorphLabel]["sMorphHead"] == 'Pose'){
					sMorphName = s_aMorphs[s_aMorphLabel]["sMorphName"];
					}
					else{
						sMorphName = s_aMorphLabel
					}
				}
				else{
					s_sMorphRules += getMorphPresets(s_aMorphLabel);
					}
				s_sMorphRules += sMorphName + "\n1\n";
			}
		}
		
		s_sMorphRules += "Anything\n0";

		return true;
	};
	/*********************************************************************/
	// void : ...
	function writeBoneData( oBaseNode, sFilename )
	{
		var oNode;
		var vecOrigin;
		var vecEnd;
		
		var aChildren = oBaseNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		
		var aData = new Array( nChildren );
		
		for( var i = 0; i < nChildren; i += 1 ){
			oNode = aChildren[i];
			if( !oNode.inherits( "DzBone" ) ){
				continue;
			}
			
			vecOrigin = oNode.getOrigin( true );
			vecEnd = oNode.getEndPoint( true );
			
			aData[i] = [
				oNode.name,
				vecOrigin.x,
				vecOrigin.y,
				vecOrigin.z,
				vecEnd.x,
				vecEnd.y,
				vecEnd.z
				]
				.concat( getBoneTransformValues( oNode ) )
				.join( "," );
		}
		
		aData = aData.filter( Boolean );
		if( aData.length < 1 ){
			return;
		}
		
		writeDataFile( aData, sFilename );
	};
	
	/*********************************************************************/
	// Array<Number> : ...
	// TODO : refactor - efficiency
	function getBoneTransformValues( oNode )
	{
		var aPosRotScale = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
		
		var aAxis = [ "X", "Y", "Z" ];
		var regxWhitespace = /\s+/g;
		
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		var sLabel;
		var sName;
		
		var aProperties = getElementProperties( oNode, true, true );
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProperty = aProperties[i];
			oOwner = oProperty.getOwner();
			if( !oOwner.inherits( "DzBone" ) ){
				continue;
			}
			
			for( var j = 0; j < aAxis.length; j += 1 ){
				sAxis = aAxis[j];
				aNames = [ sAxis + "Translate", sAxis + "Rotate" ];//Skip sAxis + "Scale"
				for( var k = 0; k < aNames.length; k += 1 ){
					sName = aNames[k];
					if( oProperty.name == sName ){
						if( !oProperty.isHidden() ){
							sLabel = oProperty.getLabel().toLowerCase().replace( regxWhitespace, "" );
							sName = sName.toLowerCase().replace( regxWhitespace, "" );
							if( !sName.startsWith( sLabel ) ){
								aPosRotScale[k*3+j] = 1;
							}
						}
					}
				}
			}
		}
		
		return aPosRotScale;
	};
	
	/*********************************************************************/
	// void : ...
	function writeMemo( sFilename, sMemo )
	{
		writeDataFile( [ sMemo ], sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function applyDefaultTransforms( oBaseNode )
	{
		var oNode;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( getKigo( oNode ) == "B" ){
				oNode.setLocalPos( s_vecDef );
				oNode.setLocalRot( s_quatDef );
				oNode.setLocalScale( s_mtxDef );
			}
		}
		
		oBaseNode.setLocalPos( s_vecDef );
		oBaseNode.setLocalRot( s_quatDef );
		oBaseNode.setLocalScale( s_mtxDef );
	};
	
	/*********************************************************************/
	// void : ...
	function writePoseData( oBaseNode, sFilename, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( bIsFigure && oTopNode.name != "hip" ){
				continue;
			}
			
			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes < 1 ){
			return;
		}
		
		var oNode;
		var sKigo;
		var vecPos;
		var quatRot;
		var mtxScale;
		var sLine;
		
		var aData = new Array( nNodes );
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sKigo = getKigo( oNode );
			vecPos = oNode.getLocalPos();
			quatRot = oNode.getLocalRot();
			mtxScale = oNode.getLocalScale();
			
			s_aPoseData.push( [ oNode.name, sKigo, vecPos, quatRot, mtxScale ] );
			
			aData[i] = [
				oNode.getLabel(),
				oNode.name,
				sKigo,
				vecPos.x,
				vecPos.y,
				vecPos.z,
				oNode.getXRotControl().getLocalValue(),
				oNode.getYRotControl().getLocalValue(),
				oNode.getZRotControl().getLocalValue(),
				mtxScale.m11,
				mtxScale.m22,
				mtxScale.m33
				].join( "," );
		}
		
		writeDataFile( aData, sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function restorePose( oBaseNode )
	{
		var oTopNode;
		var aNodes;
		var oNode;
		var aPose;
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( oTopNode.name != "hip" ){
				continue;
			}
			
			aNodes = oTopNode.getNodeChildren( true );
			aNodes.push( oTopNode );
			aNodes.unshift( oBaseNode );
			for( var j = 0; j < aNodes.length; j += 1 ){
				oNode = aNodes[j];
				if( getMeshType( oNode ) != s_oMeshTypes.Bone && j > 0 ){
					continue;
				}
				
				for( var k = 0; k < s_aPoseData.length; k += 1 ){
					aPose = s_aPoseData[k];
					if( aPose[0] == oNode.name ){
						oNode.setLocalPos( aPose[2] );
						oNode.setLocalRot( aPose[3] );
						oNode.setLocalScale( aPose[4] );
						break;
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function setLock( oBaseNode, bLock, bIsFigure )
	{
		var aNodes = oBaseNode.getNodeChildren( true );
		if( !bIsFigure ){
			aNodes.push( oBaseNode );
		}
		
		var aAxis = [ "X", "Y", "Z" ];
		
		var oNode;
		var aProperties;
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getKigo( oNode ) == 'B' ){
				continue;
			}
			
			aProperties = getElementProperties( oNode, true, true );
			for( var j = 0; j < aProperties.length; j += 1 ){
				oProperty = aProperties[ j ];
				oOwner = oProperty.getOwner();
				if( !oOwner.inherits( "DzBone" ) ){
					continue;
				}
				
				for( var k = 0; k < aAxis.length; k += 1 ){
					sAxis = aAxis[k];
					aNames = [ sAxis + "Translate", sAxis + "Rotate", sAxis + "Scale" ];
					for( var m = 0; m < aNames.length; m += 1 ){
						if( oProperty.name == aNames[m] ){
							oProperty.lock( bLock );
						}
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : rename
	function getKigo( oNode )
	{
		if( oNode.inherits( "DzBone" ) ){
			return "B";
		}
		
		if( oNode.inherits( "DzLight" ) ){
			return "L";
		}
		
		if( oNode.inherits( "DzCamera" ) ){
			return "C";
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return "E";
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return "E";
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return "E";
		}
		
		return "M";
	};
	
	/*********************************************************************/
	// void : ...
	// Morph names that are too long will cause an error in Blender 2.79.
	// Note: destructive - modifies the scene contents
	function truncateSkeletonNames( oBaseNode )
	{
		var oNode;
		var sName;
		var sTmp;
		
		var nCount = 0;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			sName = oNode.name;
			if( sName.length >= s_nMaxName ){
				sTmp = sName.substring( 0, s_nMaxName-2 );
				nCount = nCount % 36;
				sTmp = sTmp + "_" + s_sAlf.substr( nCount, 1 );
				oNode.name = sTmp;
				s_nLenName = s_nMaxName;
				nCount = nCount + 1;
			} else {
				if( sName.length > s_nLenName ){
					s_nLenName = sName.length;
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// Delete previous export
	// TODO : refactor - efficiency
	function prepareForExport( nType )
	{
		var oDir = new DzDir( "" );
		var sPath = oDir.homePath() + "/";
		
		s_sRootPath = sPath;
		
		var aFiles;
		var sDelPath;
		var oDelDir = new DzDir( "" );
		
		var aSubs = [ "Documents", "DTB", s_sEnv, s_sFig ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath = s_sRootPath + aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
			
			if( i < 2 ){
				s_sRootPath = sPath;
			} else {
				if( (i == 3 && nType == s_oExportTypes.EnvProp)
				|| (i == 2 && nType == s_oExportTypes.Figure) ){
					continue;
				}
				
				oDir.setPath( sPath );
				
				aFiles = oDir.getFilesFromDir( [], true );
				for( var j = 0; j < aFiles.length; j += 1 ){
					oDir.remove( aFiles[j] );
				}
				
				for( var j = 0; j < 100; j += 1 ){
					sDelPath = sPath + "/" + aSubs[i] + j;
					oDelDir.setPath( sDelPath );
					if( oDelDir.exists() ){
						oDir.rmdir( sDelPath );
					} else {
						break;
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function makeEndDir( nIdx, sName )
	{
		var oDir = new DzDir( "" );
		
		var sPath = s_sRootPath;
		
		var aSubs = [ sName, sName + nIdx ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath += aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	// Decide subdivison level Dialog.
	function promptMeshResolution( oNode )
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = s_sToolName + ": SubD Level";
		
		var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
		
		if( oNode ){
			wDlg.caption += " - " + oNode.getLabel();
		}
		
		var oDlgWgt = wDlg.getWidget();
		oDlgWgt.objectName = sKey;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		for( var i = 0; i < 3; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = "SubDivision Level " + i;
		}
		wOptBG.selected = 0;
		
		wDlg.addWidget( wOptBG );
		
		if( !wDlg.exec() ){
			return -1;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// void : ...
	// No eyelashes on .OBJ
	function setEyelashVisibility( oBaseNode, bOnOff )
	{
		var oNode;
		
		var aHide = [ "Eyelashes", "Eye_1", "Eye_2", "_Shell" ];
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( oNode.getNodeParent() == oBaseNode ){
				for( var j = 0; j < aHide.length; j += 1 ){ 
					if( oNode.name.indexOf( aHide[j] ) > 0 ){
						oNode.setVisible( bOnOff );
					}
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - use oNode.assetUri instead of oNode.name
	function buildRootLists()
	{
		var oNode;
		var aChildren;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( !oNode.isVisible() ){
				if( oNode.isRootNode() ){ 
					oNode.setVisible( true );
					aChildren = oNode.getNodeChildren( true );
					for( var j = 0; j < aChildren.length; j += 1 ){
						aChildren[j].setVisible( true );
					}
				}
				
				continue;
			}
			
			if( oNode.isRootNode() && oNode.isVisible() ){
				if( 
				(oNode.name.startsWith( "Genesis8Female" )
				|| oNode.name.startsWith( "Genesis8Male" )
				|| oNode.name.startsWith( "Genesis3Male" )
				|| oNode.name.startsWith( "Genesis3Female" ))
					&& oNode.name.indexOf( "Eyelash" ) < 0
				){
					s_aFigures.push( oNode );
				} else {
					s_aEnvProp.push( oNode );
				}
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function promptExportType()
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = "Select Export Type";
		
		var wLyt = new DzVBoxLayout( wDlg );
		wLyt.autoAdd = true;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		var aOptions = [ "Environment/Props", "Genesis8/3", "Both" ];
		for( var i = 0; i < aOptions.length; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = aOptions[i];
		}
		wOptBG.selected = s_oExportTypes.Figure;
		
		wDlg.addWidget( wOptBG );
		
		var oWidget = wDlg.getWidget();
		var sizeHint = oWidget.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 200 ? 200 : sizeHint.width;
		wDlg.setFixedSize( nWidth, nHeight );
		
		if( !wDlg.exec() ){
			return s_oExportTypes.None;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// Boolean : ...
	function isGenital( oNode )
	{
		var aKeys = [ "genital", "malegen_" ];
		if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
			return false;
		}
		
		var sName = oNode.name.toLowerCase();
		for( var i = 0; i < aKeys.length; i += 1 ){
			if( sName.length == 2 && sName == aKeys[i]
			|| sName.length > 2 && sName.indexOf( aKeys[i] ) >= 0 ){
				if( oNode.findNodeChild( "hip", false ) ){
					return true;
				}
			}
		}
		
		return false;
	};
	
	/*********************************************************************/
	// void : ...
	// Mesh consisting of only edges and points cannot be FBX transferred.
	// Even if it is invisible, it will be transferred, so there is no choice but to delete it.
	// Note: destructive - modifies the scene contents
	function removeIncompatibleNodes( oBaseNode )
	{
		var oNode;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		var aDelNodes = new Array( aNodes.length );
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( oNode.isRootNode() ){
				continue;
			}
			
			if( getMeshType( oNode ) == s_oMeshTypes.NoFacets ){
				aDelNodes[i] = oNode;
			}
		}
		
		aDelNodes = aDelNodes.filter( Boolean );
		
		for( var i = 0; i < aDelNodes.length; i += 1 ){
			oNode = aDelNodes[i];
			oBaseNode.removeNodeChild( oNode, true );
			oNode.setVisible( false );
			if( oNode.getLabel().endsWith( "dForce" ) ){
				Scene.removeNode( oNode );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function getMeshType( oNode )
	{
		if( !oNode ){
			return s_oMeshTypes.Other; //0
		}
		
		if( oNode.inherits( "DzBone" ) ){
			return s_oMeshTypes.Bone; //-1
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return s_oMeshTypes.Empty; //-3
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return s_oMeshTypes.Other; //0
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return s_oMeshTypes.Other; //0
		}
		
		var nFacets = oMesh.getNumFacets();
		if( nFacets < 1 && oMesh.name.toLowerCase().indexOf( "eyebrow" ) < 0 ){
			return s_oMeshTypes.NoFacets; //-2
		}
		
		if( nFacets > 14000 ){
			return s_oMeshTypes.Figure; //3
		}
		
		if( oNode.isRootNode() ){
			return s_oMeshTypes.Other; //0
		}
		
		return s_oMeshTypes.Mesh; //1
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : return success, error code, and/or message
	function writeDataFile( aData, sFilename )
	{
		var oFile = new DzFile( sFilename );
		if( !oFile.open( DzFile.WriteOnly ) ){
			print( String( "Unable to open \"%1\" for writing." ).arg( sFilename ) );
			
			return;
		}
		
		for( var i = 0; i < aData.length; i += 1 ){
			oFile.writeLine( aData[i] );
		}
		
		oFile.close();
	};
	
	/*********************************************************************/
	// void : ...
	// The mesh attached to the bone moves directly under the figure
	// Note: destructive - modifies the scene contents
	function flattenObjectHierarchy( oBaseNode )
	{
		var oChildLvl1;
		var vecChildLvl1Pos;
		var quatChildLvl1Rot;
		
		var aChildrenLvl2;
		var oChildLvl2;
		var vecChildLvl2Pos;
		var quatChildLvl2Rot;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			if( getMeshType( oChildLvl1 ) != s_oMeshTypes.Empty ){
				continue;
			}
			
			vecChildLvl1Pos = oChildLvl1.getLocalPos();
			quatChildLvl1Rot = oChildLvl1.getLocalRot();
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( true );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				vecChildLvl2Pos = oChildLvl2.getLocalPos();
				quatChildLvl2Rot = oChildLvl2.getLocalRot();
				
				vecChildLvl2Pos.x += vecChildLvl1Pos.x;
				vecChildLvl2Pos.y += vecChildLvl1Pos.y;
				vecChildLvl2Pos.z += vecChildLvl1Pos.z;
				
				quatChildLvl2Rot.x += quatChildLvl1Rot.x;
				quatChildLvl2Rot.y += quatChildLvl1Rot.y;
				quatChildLvl2Rot.z += quatChildLvl1Rot.z;
				
				oChildLvl2.setLocalPos( vecChildLvl2Pos );
				oChildLvl2.setLocalRot( quatChildLvl2Rot );
				
				oBaseNode.addNodeChild( oChildLvl2 );
			}
		}
	};
	
	/*********************************************************************/
	// Array<String> : ...
	function getParentingData( oParentNode, oBaseNode )
	{
		var aData = [];
		
		var oNode;
		var sName;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		aNodes.push( oBaseNode );
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
				continue;
			}
			
			sName = oNode.name;
			for( var j = 1; j <= 10; j += 1 ){
				if( !oNode.getLabel().endsWith( " (" + j + ")" ) ){
					continue;
				}
				
				sName += "_dup_" + j;
			}
			
			aData.push( oParentNode.name + "," + sName );
		}
		
		return aData;
	};
	
	/*********************************************************************/
	// void : ...
	function writeParentingData( oBaseNode, sFilename )
	{
		var aData = [];
		
		var oChildLvl1;
		
		var aChildrenLvl2;
		var oChildLvl2;
		
		var aChildrenLvl3;
		var oChildLvl3;
		
		var nMeshType;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( false );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				nMeshType = getMeshType( oChildLvl2 );
				//It's mesh(child)
				if( nMeshType > s_oMeshTypes.Other ){
					//Parent is bone
					if( getMeshType( oChildLvl1 ) == s_oMeshTypes.Bone ){
						aData = aData.concat( getParentingData( oChildLvl1, oChildLvl2 ) );
					}
				//It's Empty(Child)
				} else if( nMeshType == s_oMeshTypes.Empty ){
					aChildrenLvl3 = oChildLvl2.getNodeChildren( false );
					for( var k = 0; k < aChildrenLvl3.length; k += 1 ){
						oChildLvl3 = aChildrenLvl3[k];
						//Grandchild is mesh.
						//child's parent, parent child (sibling?) is bone
						if( getMeshType( oChildLvl3 ) > s_oMeshTypes.Other ){
							if( getMeshType( oChildLvl1.getNodeParent() ) == s_oMeshTypes.Bone ){
								aData = aData.concat( getParentingData( oChildLvl1, oChildLvl3 ) );
							}
						}
					}
				}
			}
		}
		
		if( aData.length > 0 ){
			writeDataFile( aData, sFilename );
		}
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : remove - not used
	// Note: destructive - modifies the scene contents
	function lockNodeTransforms( oNode )
	{
		oNode.getToolXRotControl().lock( true );
		oNode.getToolYRotControl().lock( true );
		oNode.getToolZRotControl().lock( true );
		oNode.getOrientXControl().lock( true );
		oNode.getOrientYControl().lock( true );
		oNode.getOrientZControl().lock( true );
	};
	
	/*********************************************************************/
	// String : ...
	// TODO : remove - not used
	function getTransformAsCSV( oNode, vecPos, mtxScale )
	{
		var sResult = vecPos.x + "," + vecPos.y + "," + vecPos.z + ",";
		
		sResult += oNode.getXRotControl().getLocalValue() + ",";
		sResult += oNode.getYRotControl().getLocalValue() + ",";
		sResult += oNode.getZRotControl().getLocalValue() + ",";
		
		sResult += mtxScale.m11 + "," + mtxScale.m22 + "," + mtxScale.m33;
		
		return sResult;
	};
	
	/*********************************************************************/
	// void : ...
	// Apply subdivision levels to figures and genitals.
	function setSubDivLevelAll( oBaseNode, nLevel )
	{
		var bIsBody;
		var bIsGen;
		var nLev;
		var oNode;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			bIsBody = oNode == oBaseNode;
			bIsGen = !bIsBody && oNode.getNodeParent() == oBaseNode && isGenital( oNode );
			nLev = 0;
			if( bIsBody || bIsGen ){
				nLev = nLevel;
			}
			
			setSubDivLevel( oNode, nLev );
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setSubDivLevel( oNode, nLevel )
	{
		var aProps = [ "lodlevel", "SubDIALevel" ];
		var oObject = oNode.getObject();
		if( !oObject ){
			return;
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return;
		}
		
		var oProp;
		for( var i = 0; i < aProps.length; i += 1 ){
			oProp = oShape.findProperty( aProps[i] );
			if( oProp ){
				if( oProp.isLocked() ){
					oProp.lock( false );
				}
				
				if( i == 0 && nLevel == 0 ){
					oProp.setValue( "Basic" );
				} else {
					oProp.setValue( nLevel );
				}
				
				if( nLevel > 0 ){
					oProp.lock( true );
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setHideRoot( bIsFigure, bYesNo )
	{
		if( bIsFigure ){
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				setVisible( s_aFigures[i], bYesNo );
			}
		} else {
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				setVisible( s_aEnvProp[i], bYesNo );
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setVisible( oBaseNode, bYesNo )
	{
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			aChildren[i].setVisible( bYesNo );
		}
		
		oBaseNode.setVisible( bYesNo );
	};

	/*********************************************************************/
	// Number : Get the sign of the input number
	function getSign( nInput )
	{
		if( nInput >= 0 ){
			return 1;
		} else{
			return -1;
		}
	}

	/*********************************************************************/
	// Number : Get the direction of the bone's look at axis. 1 or -1
	function getLookAtDirection( oNode )
	{
		var vecLookAtAxis = oNode.getEndPoint().subtract( oNode.getOrigin() );
		
		var nSign = 1;
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nSign = getSign( vecLookAtAxis.x );
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nSign = getSign( vecLookAtAxis.y );
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nSign = getSign( vecLookAtAxis.z );
		}
		
		return nSign;
	};

	/*********************************************************************/
	// DzVec3 : Get the second axis of the node
	function getNodeSecondAxis( oNode )
	{
		var vecSecondAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().secondAxis == 0 ){
			vecSecondAxis.x = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 1 ){
			vecSecondAxis.y = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 2 ){
			vecSecondAxis.z = nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecSecondAxis = quatOrientation.multVec( vecSecondAxis );
		
		return vecSecondAxis;
	};

	/*********************************************************************/
	// DzVec3 : Get the primary axis of the node
	function getNodePrimaryAxis( oNode, nBoneLength )
	{
		var vecFirstAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().firstAxis == 0 ){
			vecFirstAxis.x = nBoneLength * nSign;
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			vecFirstAxis.y = nBoneLength * nSign;
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			vecFirstAxis.z = nBoneLength * nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecFirstAxis = quatOrientation.multVec( vecFirstAxis );
		
		return vecFirstAxis;
	};

	/*********************************************************************/
	// Float : Get length of the bone
	function getBoneNodeLength( oNode )
	{
		var vecAlongBone = oNode.getEndPoint().subtract( oNode.getOrigin() );
		return vecAlongBone.length();
	}

	/*********************************************************************/
	// Void : Write bone's limits along with rotation orders
	function writeFigureBoneData( oBaseNode, sFilename )
	{
		if( !oBaseNode.inherits("DzFigure") ){
			return;
		}
		
		var oSkeleton = oBaseNode.getSkeleton();
		var aNodes = oSkeleton.getAllBones();
		var numFollowers = oSkeleton.getNumFollowSkeletons();
		var oFollowSkeleton;
		var aFollowNodes;
		var oFollowNode;
		var bIsNewNode;
		
		// Collect followers' bones that does not exist in the main skeleton
		for( var i = 0; i < numFollowers; i += 1 ){
			oFollowSkeleton = oSkeleton.getFollowSkeleton( i );
			aFollowNodes = oFollowSkeleton.getAllBones();
			for( var j = 0; j < aFollowNodes.length; j += 1 ){
				oFollowNode = aFollowNodes[j];
				bIsNewNode = false;
				for( var k = 0; k < aNodes.length; k += 1 ){
					if( oFollowNode.name == aNodes[k].name ){
						bIsNewNode = true;
						break;
					}
				}

				if( bIsNewNode == false ){
					aNodes = aNodes.concat( aFollowNodes[j] );
				}
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes == 0 ){
			return;
		}
		
		var oNode;
		var sRotOrder;
		var nXRotMin;
		var nXRotMax;
		var nYRotMin;
		var nYRotMax;
		var nZRotMin;
		var nZRotMax;
		
		var aLimitsData = new Array( nNodes );
		var aHeadTailData = new Array( nNodes );
		var aSkeletonData = new Array( 1 );
		
		// To account for the scale on the skeleton due to morphs
		var nSkeletonScale = oBaseNode.getScaleControl().getValue();
		aSkeletonData[0] = ["skeletonScale", nSkeletonScale].join(",");
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			
			sRotOrder = oNode.getRotationOrder().toString();
			nXRotMin = oNode.getXRotControl().getMin();
			nXRotMax = oNode.getXRotControl().getMax();
			nYRotMin = oNode.getYRotControl().getMin();
			nYRotMax = oNode.getYRotControl().getMax();
			nZRotMin = oNode.getZRotControl().getMin();
			nZRotMax = oNode.getZRotControl().getMax();
			aLimitsData[i] = [
				oNode.getName(),
				sRotOrder,
				nXRotMin, nXRotMax,
				nYRotMin, nYRotMax,
				nZRotMin, nZRotMax
				].join(",");
			
			nBoneLength = getBoneNodeLength( oNode );
			vecPrimaryAxis = getNodePrimaryAxis( oNode, nBoneLength );
			vecHead = oNode.getOrigin( false );
			vecTail = vecHead.add( vecPrimaryAxis );
			vecSecondAxis = getNodeSecondAxis( oNode );
			aHeadTailData[i] = [
				oNode.getName(),
				vecHead.x * nSkeletonScale,
				vecHead.y * nSkeletonScale,
				vecHead.z * nSkeletonScale,
				vecTail.x * nSkeletonScale,
				vecTail.y * nSkeletonScale,
				vecTail.z * nSkeletonScale,
				vecSecondAxis.x,
				vecSecondAxis.y,
				vecSecondAxis.z
				].join(",");
		}
		
		writeDataFile( aLimitsData, sFilename + "_boneLimits.csv" );
		writeDataFile( aHeadTailData, sFilename + "_boneHeadTail.csv" );
		writeDataFile( aSkeletonData, sFilename + "_skeletonData.csv" );
	};
	/*********************************************************************/	
	// Configure DTU File
	// Running into issue of Materials becoming one list. 
	// void : ...
	function writeConfiguration(oNode,sFilename)
	{
		var sDTUfilename = sFilename + ".dtu";
		var oDTUfile = new DzFile(sDTUfilename);
		oDTUfile.open(DzFile.WriteOnly);
		oDTUfile.writeLine("{" );
		oDTUfile.writeLine("				\"Asset Name\": \"" + oNode.getLabel() + "\",");
		oDTUfile.writeLine("				\"Materials\": [ " );
		aFigureMats = writeMaterials(oNode);
		oDTUfile.write(JSON.stringify(aFigureMats,null,4))
		var aChildren = oNode.getNodeChildren( true );
		var iChildren = aChildren.length;
		if (iChildren > 0)
		{
			
			oDTUfile.writeLine(",")
			for ( var i = 0; i < iChildren; i++)
			{
				var oChild = aChildren[i]; 
				aChildMats = writeMaterials(oChild);
				if (aChildMats != false)
				{
					oDTUfile.write(JSON.stringify(aChildMats,null,4));
					
					
					oDTUfile.writeLine(",");
						
				}
				
			}
		}
		
		// Place Holder to deal with format
		oDTUfile.writeLine("1]}" );
		oDTUfile.close();

	}
	/*********************************************************************/	
	// Cycle through all the Materials on a Node and return an array
	// Array : ...
	function writeMaterials(oNode)
	{
		
		var oObj = oNode.getObject();
		if (oObj != null)
		{
			var oShape = oObj.getCurrentShape();
			var nMat = oShape.getNumMaterials();
			var Materials = [];
			if (oShape)
			{
				for (var k=0; k < nMat; k++)
				{
					var AssetInfo = {};
					var Properties = [];
					var oMat = oShape.getMaterial(k);
					if (oMat)
					{	
						
						AssetInfo["Asset Name"] = oNode.getLabel();
						AssetInfo["Material Name"] = oMat.getName();
						AssetInfo["Material Type"] = oMat.getMaterialName();
						
						var presentation = oNode.getPresentation();
					
						if (presentation != undefined)
						{	
							
							presentationType = "test"
							AssetInfo["Value"]  = presentationType;
						}
						else {
							AssetInfo["Value"]  = "Unknown";
						}
						
						for (var propertyIndex = 0; propertyIndex <  oMat.getNumProperties(); propertyIndex++)
						{	
							var oProperty =oMat.getProperty(propertyIndex);
							
							var ImageProperty = oProperty.inherits("DzImageProperty");
							if (ImageProperty)
							{
								var sName = oProperty.getName();
								
								var TextureName ="";
								if (oProperty.getValue()){
									TextureName = oProperty.getValue().getFilename();
									
								}
							
								Properties.push(
									{
									"Name" : sName,
									"Value" : oMat.getDiffuseColor().name(),
									"Data Type" : "Texture",
									"Texture" : TextureName
									}
								);

							}
							
							var ColorProperty = oProperty.inherits("DzColorProperty");
							if (ColorProperty)
							{
						
								var sName = oProperty.getName();
								
								var TextureName ="";
								if (oProperty.getMapValue()){
									TextureName = oProperty.getMapValue().getFilename();
								}
								Properties.push(
									{
									"Name" : sName,
									"Value" : oProperty.getColorValue(),
									"Data Type" : "Color",
									"Texture" : TextureName
									}
								)
							}
							var NumericProperty = oProperty.inherits("DzNumericProperty");
							if (NumericProperty)
							{
								var sName = oProperty.getName();
								
								var TextureName ="";
								if (oProperty.getMapValue()){
									TextureName = oProperty.getMapValue().getFilename();
								}
								Properties.push(
									{
									"Name" : sName,
									"Value" : oProperty.getValue(),
									"Data Type" : "Double",
									"Texture" : TextureName
									}
								)
							}
						
						}
					AssetInfo["Properties"] = Properties 
					Materials.push(AssetInfo)	
						
					}
					
				}				
			
			}
			
			return Materials
		}
		else{
			return false
		}
	}
	/*********************************************************************/
	// void : ...
	function main()
	{
		var bDebugFBX = false;
		
		buildRootLists();
		
		if( s_aFigures.length > 2 ){
			if( MessageBox.warning(
				qsTr( "Transferring 3 or more figures with clothing or hair may freeze and stop." ),
				s_sToolName, qsTr( "&OK" ), qsTr( "&Cancel" ) ) == 1 ){
				return;
			}
		}
		
		if( s_aFigures.length == 0 && s_aEnvProp.length == 0 ){
			return;
		} else if( s_aFigures.length > 0 && s_aEnvProp.length > 0 ){
			s_nExportType = s_oExportTypes.Both;
		} else if( s_aEnvProp.length == 0 ){
			s_nExportType = s_oExportTypes.Figure;
		} else if( s_aFigures.length == 0 ){
			s_nExportType = s_oExportTypes.EnvProp;
		}
		
		if( s_nExportType == s_oExportTypes.Both ){
			s_nExportType = promptExportType();
		}
		
		if( s_nExportType == s_oExportTypes.None ){
			return;
		}
		
		prepareForExport( s_nExportType );
		
		var sFileBasename;
		
		if( s_nExportType == s_oExportTypes.Both
		|| s_nExportType == s_oExportTypes.Figure ){
			setHideRoot( false, false );
			
			var oFigure;
			var nLevel;
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				oFigure = s_aFigures[i];
				
				for( var j = 0; j < s_aFigures.length; j += 1 ){
					setVisible( s_aFigures[j], i == j );
				}
				
				nLevel = promptMeshResolution( oFigure );
				if( nLevel < 0 ){
					continue;
				}
				
				sFileBasename = String( "%1%2/%2%3/%2" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				
				setLock( oFigure, true, true );
				makeEndDir( i, s_sFig );
				writeFigureBoneData( oFigure, sFileBasename );
				writePoseData( oFigure, sFileBasename + ".csv", true );
				writeParentingData( oFigure, sFileBasename + ".dat" );
				writeConfiguration(oFigure,sFileBasename);
				setSubDivLevelAll( oFigure, nLevel );
				buildMorphList( oFigure );
	
				if( !promptMorphRules( oFigure) ){
					continue;
				}
				
				setEyelashVisibility( oFigure, false );
				exportOBJ( oFigure, s_sFig, i );
				setEyelashVisibility( oFigure, true );
				removeIncompatibleNodes( oFigure );
				exportFBX( oFigure, s_sFig, i , bDebugFBX );
				setLock( oFigure, false, true );
				restorePose( oFigure );
			}
		}
		
		if( s_nExportType != s_oExportTypes.Figure ){
			setHideRoot( true, false );
			
			var oNode;
			var bIsBone;
			var sEnvPath;
			var sPoseFilename;
			var sBoneFilename;
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				oNode = s_aEnvProp[i];
				
				for( var j = 0; j < s_aEnvProp.length; j += 1 ){
					setVisible( s_aEnvProp[j], i == j );
				}
				
				bIsBone = oNode.getSkeleton() != null;
				if( bIsBone ){
					flattenObjectHierarchy( oNode );
				}
				
				setLock( oNode, true, false );
				
				setSubDivLevelAll( oNode, 0 );
				
				sEnvPath = String( "%1%2/%2%3/" ).arg( s_sRootPath ).arg( s_sEnv ).arg( i );
				makeEndDir( i, s_sEnv );
				
				if( oNode.name.startsWith( "Genesis" ) ){
					applyDefaultTransforms( oNode );
				}
				
				exportFBX( oNode, s_sEnv, i, bDebugFBX );
				
				sFileBasename = sEnvPath + s_sEnv;
				sPoseFilename = sFileBasename + ".csv";
				sBoneFilename = sFileBasename + ".bon";
				
				if( bIsBone ){
					writeBoneData( oNode, sBoneFilename );
				} else {
					writePoseData( oNode, sPoseFilename, false );
					writeMemo( sEnvPath + "nobone.txt", "not skeleton" );
				}
				
				setLock( oNode, false, false );
			}
		}
		
		setHideRoot( true, true );
		setHideRoot( false, true );
	};
	
	/*********************************************************************/
	main();
	
})();